<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ğŸ± è²“å’ªå°å­¸å ‚ </title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#FF9F1C">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="è²“å’ªå°å­¸å ‚">
    <link rel="apple-touch-icon" href="icons/icon-180.png">
    <link rel="icon" href="icons/icon-192.png" sizes="192x192">
    <!-- å¼•å…¥å­—å‹èˆ‡åœ–ç¤ºåº« -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&family=Zen+Maru+Gothic:wght@500;900&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* éŠæˆ²å°ˆå±¬æ¨£å¼ */
        :root {
            --primary: #FF9F1C;
            --secondary: #FFBF69;
            --bg-color: #CBF3F0;
            --text: #2EC4B6;
            --app-height: 100dvh;
            --app-width: 100vw;
        }

        html,
        body {
            font-family: 'Zen Maru Gothic', 'Noto Sans TC', sans-serif;
            background-color: var(--bg-color);
            background-image: radial-gradient(#ffffff 20%, transparent 20%), radial-gradient(#ffffff 20%, transparent 20%);
            background-position: 0 0, 50px 50px;
            background-size: 100px 100px;
            overflow: hidden; /* é˜²æ­¢æ²å‹• */
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            height: var(--app-height);
            width: var(--app-width);
            position: fixed;
            margin: 0;
            overscroll-behavior: none;
        }
        *, *::before, *::after {
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }
        .allow-scroll {
            touch-action: pan-y;
            overscroll-behavior: contain;
        }

        /* 3D æŒ‰éˆ•æ•ˆæœ */
        .btn-3d {
            transition: all 0.1s;
            box-shadow: 0px 5px 0px 0px rgba(0,0,0,0.2);
            transform: translateY(0);
            cursor: pointer;
        }
        .btn-3d:active {
            transform: translateY(5px);
            box-shadow: 0px 0px 0px 0px rgba(0,0,0,0.2);
        }

        /* å¡ç‰‡ç¿»è½‰æ ¸å¿ƒ */
        .perspective-1000 { perspective: 1000px; }
        .transform-style-3d { transform-style: preserve-3d; }
        .backface-hidden { backface-visibility: hidden; }
        .rotate-y-180 { transform: rotateY(180deg); }
        
        .card-inner { transition: transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1); }
        .card-inner.card-flipped { transform: rotateY(180deg); }

        /* è²“å’ªæµ®å‹•å‹•ç•« */
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-15px); }
            100% { transform: translateY(0px); }
        }
        .cat-anim { animation: float 3s ease-in-out infinite; }

        /* è²“å’ªç”Ÿæ°£æŠ–å‹•å‹•ç•« */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .cat-angry { animation: shake 0.5s; }
        .cat-walk {
            position: relative;
            --cat-x: 0px;
            --cat-scale: 1;
            transform: translate3d(var(--cat-x), 0, 0) scale(var(--cat-scale));
            transition: transform 2.4s ease-in-out;
            will-change: transform;
        }
        .cat-walk:active {
            --cat-scale: 0.95;
        }
        .cat-float {
            position: relative;
        }
        .cat-body {
            position: relative;
            transition: transform 0.3s ease;
        }
        .cat-body.facing-left {
            transform: scaleX(-1);
        }

        /* Boss å—å‚·å‹•ç•« */
        @keyframes damage-shake {
            0% { transform: translate(0, 0) rotate(0deg); filter: hue-rotate(0deg); }
            20% { transform: translate(-10px, 0) rotate(-5deg); filter: hue-rotate(90deg) brightness(0.5) sepia(1) saturate(1000%) hue-rotate(-50deg); }
            40% { transform: translate(10px, 0) rotate(5deg); }
            60% { transform: translate(-10px, 0) rotate(-5deg); }
            80% { transform: translate(10px, 0) rotate(5deg); }
            100% { transform: translate(0, 0) rotate(0deg); filter: none; }
        }
        .boss-damage { animation: damage-shake 0.5s; }

        /* Boss è£œè¡€å‹•ç•« */
        @keyframes heal-glow {
            0% { transform: scale(1); filter: drop-shadow(0 0 0px green); }
            50% { transform: scale(1.1); filter: drop-shadow(0 0 20px #00ff00); }
            100% { transform: scale(1); filter: drop-shadow(0 0 0px green); }
        }
        .boss-heal { animation: heal-glow 0.6s; }

        /* Emoji ç²’å­ç‰¹æ•ˆ */
        @keyframes emoji-pop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            50% { transform: translate(var(--tx), var(--ty)) scale(1.2) rotate(var(--rot)); opacity: 1; }
            100% { transform: translate(var(--tx), calc(var(--ty) + 30px)) scale(0.8) rotate(var(--rot)); opacity: 0; }
        }
        .emoji-particle {
            position: absolute;
            pointer-events: none;
            font-size: 2rem;
            z-index: 50;
            animation: emoji-pop 0.8s ease-out forwards;
            will-change: transform, opacity;
        }

        /* Majic å°è£é£¾ */
        .gene-overlay {
            position: absolute;
            width: 120px;
            height: 120px;
            right: -12px;
            bottom: -6px;
            pointer-events: none;
            border-radius: 999px;
            border: none;
            background: transparent;
            box-shadow: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .organ-container {
            position: absolute;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .organ-source {
            position: absolute;
            font-size: 90px;
            line-height: 1;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            user-select: none;
        }
        .gene-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            aspect-ratio: 1 / 1;
            min-height: 2.4rem;
            background: #f8fafc;
            border: 1px solid #c7d2fe;
            border-radius: 0.75rem;
            padding: 0.35rem;
            font-size: 1.25rem;
            transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease;
        }
        .gene-btn:hover {
            transform: translateY(-2px);
            border-color: #6366f1;
            background: #eef2ff;
        }
        .gene-btn.selected {
            border-color: #4f46e5;
            background: #e0e7ff;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
        }
        .gene-btn.locked {
            opacity: 0.35;
            filter: grayscale(1);
            cursor: not-allowed;
        }
        .bath-zone {
            position: relative;
            width: 100%;
            height: 260px;
            border-radius: 24px;
            background: linear-gradient(180deg, rgba(56, 189, 248, 0.25), rgba(125, 211, 252, 0.15));
            border: 2px solid rgba(56, 189, 248, 0.35);
            overflow: hidden;
        }
        .bath-germ {
            position: absolute;
            width: 42px;
            height: 42px;
            border-radius: 999px;
            border: 1px solid rgba(59, 130, 246, 0.2);
            background: rgba(255, 255, 255, 0.85);
            box-shadow: 0 6px 12px rgba(59, 130, 246, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: transform 0.15s ease;
        }
        .bath-germ:active {
            transform: scale(0.9);
        }
        .treasure-canvas {
            image-rendering: pixelated;
            background: #111827;
            border-radius: 18px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.4);
            width: min(92vw, 396px);
            height: min(92vw, 396px);
            max-width: 100%;
        }
        #scene-treasure {
            padding-bottom: 9rem;
            touch-action: pan-y;
            -webkit-overflow-scrolling: touch;
        }
        .treasure-controls {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            width: min(92vw, 396px);
            z-index: 45;
        }
        .treasure-controls .treasure-control-panel {
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid #e2e8f0;
            border-radius: 18px;
            padding: 0.6rem;
            box-shadow: 0 16px 30px rgba(15, 23, 42, 0.25);
        }
        #scene-backyard {
            background-color: #dff6ff;
            background-position: center;
            background-size: cover;
            background-repeat: no-repeat;
        }
        .treasure-dpad-btn {
            background: #f8fafc;
            border: 2px solid #cbd5e1;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            color: #1f2937;
            font-weight: 700;
            touch-action: manipulation;
            transition: background 0.15s ease, transform 0.1s ease;
        }
        .treasure-dpad-btn:active {
            background: #e2e8f0;
            transform: translateY(2px);
        }
        .treasure-scanline {
            background: linear-gradient(to bottom, transparent 50%, rgba(56, 189, 248, 0.12) 51%);
            background-size: 100% 4px;
            pointer-events: none;
            position: absolute;
            inset: 0;
            opacity: 0.2;
        }
        .treasure-wheel-wrap {
            position: relative;
            width: 220px;
            height: 220px;
            margin: 0 auto;
        }
        .treasure-wheel {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 999px;
            border: 6px solid #f8fafc;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.4);
            background: conic-gradient(
                #fde68a 0deg 30deg,
                #fde047 30deg 60deg,
                #fbbf24 60deg 90deg,
                #facc15 90deg 120deg,
                #fde68a 120deg 150deg,
                #fbbf24 150deg 180deg,
                #fde047 180deg 210deg,
                #facc15 210deg 240deg,
                #fde68a 240deg 270deg,
                #fbbf24 270deg 300deg,
                #fde047 300deg 330deg,
                #facc15 330deg 360deg
            );
            transition: transform 3.2s cubic-bezier(0.2, 0.7, 0.2, 1);
        }
        .treasure-wheel-labels {
            position: absolute;
            inset: 0;
        }
        .treasure-wheel-labels span {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: 0 0;
            font-size: 12px;
            font-weight: 800;
            color: #7c2d12;
        }
        .treasure-wheel-pointer {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-bottom: 18px solid #ef4444;
            filter: drop-shadow(0 4px 4px rgba(0, 0, 0, 0.3));
        }
        .slot-reels {
            display: flex;
            gap: 12px;
            justify-content: center;
            align-items: center;
        }
        .slot-machine-window {
            width: 72px;
            height: 72px;
            background: #f8fafc;
            border-radius: 16px;
            border: 2px solid #cbd5e1;
            box-shadow: inset 0 -6px 0 rgba(0,0,0,0.06);
            overflow: hidden;
        }
        .reel-strip {
            display: flex;
            flex-direction: column;
            transform: translateY(0);
            will-change: transform;
        }
        .slot-symbol {
            height: 72px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            font-weight: 800;
            color: #0f172a;
        }
        .reel-strip.is-spinning {
            filter: blur(1.6px);
        }
        .backyard-cat-entity {
            position: absolute;
            width: 64px;
            height: 64px;
            left: 0;
            top: 0;
            --bx: 0px;
            --by: 0px;
            transform: translate3d(var(--bx), var(--by), 0) scaleX(var(--flip, 1));
            transition: transform 2s linear;
            z-index: 10;
            pointer-events: none;
            will-change: transform;
        }
        .backyard-cat-entity.eating {
            transform: translate3d(var(--bx), var(--by), 0) scaleX(var(--flip, 1)) scale(1.15) !important;
            filter: brightness(1.15);
            transition: transform 0.2s;
        }
        .kibble {
            position: absolute;
            font-size: 1.5rem;
            z-index: 5;
            animation: drop-kibble 1s ease-in forwards;
            pointer-events: none;
        }
        @keyframes drop-kibble {
            from { transform: translateY(0); }
            to { transform: translateY(60vh); }
        }
        .backyard-item {
            position: absolute;
            font-size: 2rem;
            z-index: 20;
            cursor: pointer;
            animation: pop-up-down 0.6s ease-out forwards;
            transition: transform 0.1s;
        }
        .backyard-item:active {
            transform: scale(1.3);
        }
        .backyard-item.poop {
            filter: grayscale(0.4);
        }
        @keyframes pop-up-down {
            0% { transform: scale(0.5) translateY(0); opacity: 0; }
            50% { transform: scale(1.2) translateY(-40px); opacity: 1; }
            100% { transform: scale(1) translateY(0); }
        }
        .gene-tab {
            padding: 0.5rem 0.9rem;
            border-radius: 999px;
            font-weight: 700;
            font-size: 0.85rem;
            background: rgba(15, 23, 42, 0.06);
            color: #475569;
            transition: all 0.2s ease;
        }
        .gene-tab:hover {
            background: rgba(15, 23, 42, 0.12);
        }
        .gene-tab.active {
            background: linear-gradient(135deg, #38bdf8, #818cf8);
            color: #0f172a;
            box-shadow: 0 10px 20px rgba(56, 189, 248, 0.25);
        }
        .gene-fusion-stage {
            position: relative;
            width: 150px;
            height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.45);
        }
        .gene-overlay .gene-fusion-stage {
            width: 120px;
            height: 120px;
            background: transparent;
            border: none;
            box-shadow: none;
        }
        .gene-fusion-emoji {
            position: absolute;
            font-size: 64px;
            line-height: 1;
            filter: drop-shadow(0 6px 12px rgba(0,0,0,0.35));
        }
        .gene-fusion-emoji.left {
            transform: rotate(-14deg) translateX(-30px);
        }
        .gene-fusion-emoji.right {
            transform: rotate(14deg) translateX(30px);
        }
        .gene-fusion-tape {
            position: absolute;
            width: 130px;
            height: 28px;
            background: rgba(255, 255, 255, 0.25);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-10deg);
            z-index: 2;
            border-left: 2px dashed rgba(255,255,255,0.3);
            border-right: 2px dashed rgba(255,255,255,0.3);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .gene-fusion-tape::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(45deg, transparent 40%, rgba(255,255,255,0.4) 50%, transparent 60%);
        }

        @keyframes drift {
            0%, 100% { transform: translateY(0) translateX(0) rotate(0deg); opacity: 0.2; }
            50% { transform: translateY(-12px) translateX(6px) rotate(6deg); opacity: 0.4; }
        }
        .ambient-emoji {
            position: absolute;
            pointer-events: none;
            animation: drift 6s ease-in-out infinite;
        }

        .poop {
            position: absolute;
            font-size: 1.7rem;
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.15));
            cursor: pointer;
            pointer-events: auto;
            animation: poop-pop 0.25s ease-out;
        }
        @keyframes poop-pop {
            from { transform: scale(0.6); opacity: 0.4; }
            to { transform: scale(1); opacity: 1; }
        }

        /* åˆæˆç³»çµ±ï¼šEmoji ç–ŠåŠ  */
        .synth-stack {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }
        .synth-layer {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s ease;
            pointer-events: none;
        }
        .cat-filter-ice { filter: hue-rotate(180deg) saturate(150%) brightness(1.2); }
        .cat-filter-shadow { filter: brightness(0.3) contrast(1.2); }
        .cat-filter-fire { filter: sepia(1) saturate(500%) hue-rotate(-20deg); }
        .cat-filter-stone { filter: grayscale(100%) contrast(1.2); }

        @keyframes float-gentle {
            0%, 100% { transform: translate(-50%, -50%) translateY(0); }
            50% { transform: translate(-50%, -50%) translateY(-10px); }
        }
        .anim-float { animation: float-gentle 3s ease-in-out infinite; }

        @keyframes spin-slow {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        .anim-spin { animation: spin-slow 8s linear infinite; }

        @keyframes shake-angry {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            25% { transform: translate(-52%, -48%) rotate(-5deg); }
            75% { transform: translate(-48%, -52%) rotate(5deg); }
            100% { transform: translate(-50%, -50%) rotate(0deg); }
        }
        .anim-shake { animation: shake-angry 0.2s infinite; }

        /* æˆ¿é–“ Emoji è£é£¾ */
        .decor-item {
            position: absolute;
            pointer-events: none;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        #decor-window { top: 4%; left: 50%; transform: translateX(-50%); font-size: 4.5rem; opacity: 0.85; }
        #decor-rug { bottom: 14%; left: 50%; transform: translateX(-50%) scale(1.35, 1); font-size: 6rem; opacity: 0.9; }
        #decor-toy { bottom: 18%; right: 8%; font-size: 3rem; animation: float 4s ease-in-out infinite; }
        #decor-plant { bottom: 18%; left: 8%; font-size: 3.5rem; }
        #decor-lamp { top: 12%; right: 10%; font-size: 3rem; opacity: 0.9; }
        #decor-balloon { top: 8%; left: 10%; font-size: 3rem; animation: float 5s ease-in-out infinite reverse; }

        /* è£é£¾å¿«é¸ */
        .decor-quick {
            display: flex;
            gap: 0.35rem;
            align-items: center;
        }
        .decor-slot {
            width: 34px;
            height: 34px;
            border-radius: 10px;
            border: 2px dashed #cbd5f5;
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #94a3b8;
            font-size: 1.05rem;
            transition: all 0.2s ease;
        }
        .decor-slot.filled {
            border-style: solid;
            border-color: #a5b4fc;
            color: #1f2937;
            box-shadow: 0 4px 10px rgba(79, 70, 229, 0.12);
        }
        #decor-picker {
            position: absolute;
            top: 64px;
            right: 16px;
            z-index: 40;
            width: min(90%, 280px);
            background: #fff;
            border-radius: 16px;
            border: 2px solid #e0e7ff;
            box-shadow: 0 12px 30px rgba(15, 23, 42, 0.18);
            padding: 0.75rem;
        }
        .decor-picker-item {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            border: 2px solid #e2e8f0;
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            transition: all 0.2s ease;
        }
        .decor-picker-item:hover {
            border-color: #818cf8;
            box-shadow: 0 0 0 2px rgba(129, 140, 248, 0.2);
        }

        /* è¡¨æƒ…ç¬¦è™Ÿå‹•ç•« */
        @keyframes icon-float {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-100px) scale(1.5); opacity: 0; }
        }
        .float-icon {
            position: absolute;
            font-size: 3rem;
            animation: icon-float 0.8s ease-out forwards;
            pointer-events: none;
            z-index: 50;
        }

        .exp-fill { transition: width 0.5s ease-out; }
        .hp-fill { transition: width 0.3s ease-out; }

        #q-hint {
            white-space: normal;
            word-break: break-word;
            overflow-wrap: anywhere;
            text-align: center;
            line-height: 1.5;
            max-width: 100%;
        }

        .area-grid-wrap {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            justify-content: center;
            align-items: center;
        }
        .area-grid {
            display: grid;
            gap: 2px;
            background: #f3f4f6;
            padding: 6px;
            border: 2px solid #c7d2fe;
            border-radius: 12px;
            max-width: 100%;
        }
        .area-cell {
            width: var(--cell-size, 18px);
            height: var(--cell-size, 18px);
            border-radius: 4px;
            background: #60a5fa;
        }

        .story-hint {
            font-size: clamp(0.85rem, 2.3vw, 1.05rem);
        }
        .area-hint {
            font-size: 0.95rem;
            letter-spacing: 0;
        }

        #q-hint-box {
            min-height: 4.5rem;
            position: relative;
        }

        .story-mode #q-zhuyin {
            font-size: clamp(1.2rem, 3.4vw, 1.7rem);
        }
        .math-mode #q-zhuyin {
            font-size: clamp(2.2rem, 7vw, 4rem);
            letter-spacing: 0.12em;
        }
        .area-mode #q-zhuyin {
            font-size: clamp(1.4rem, 4vw, 2.2rem);
        }
        .clock-mode #q-hint-box {
            flex-direction: column;
            gap: 0.5rem;
            min-height: 7.5rem;
            padding: 0.8rem 1rem !important;
            overflow: visible;
        }
        .clock-mode #q-grid {
            display: flex;
            justify-content: center;
        }
        .clock-mode #q-zhuyin {
            font-size: clamp(1.4rem, 4.5vw, 2.2rem);
            letter-spacing: 0.06em;
        }
        .clock-mode #q-char {
            font-size: clamp(2.6rem, 7.5vw, 4.6rem);
            line-height: 1.1;
            letter-spacing: 0;
            font-family: 'Zen Maru Gothic', 'Noto Sans TC', sans-serif;
        }
        .clock-mode #a-word {
            font-size: clamp(1rem, 3.2vw, 1.25rem);
        }
        .clock-wrap {
            width: 170px;
            height: 170px;
        }
        .clock-face {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.1));
        }
        .clock-hand {
            stroke-linecap: round;
            transform-origin: 50% 50%;
        }

        .story-mode #q-hint {
            font-size: clamp(0.78rem, 2.2vw, 0.98rem);
            line-height: 1.6;
        }

        .story-mode #q-hint-box {
            margin-top: 0.5rem !important;
            padding: 0.6rem 0.8rem !important;
            max-height: clamp(9rem, 38vh, 16rem);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
        }

        .story-mode #q-hint-box span {
            display: none;
        }

        .math-mode #q-hint {
            font-size: clamp(0.9rem, 2.8vw, 1.05rem);
            letter-spacing: 0;
            color: #374151;
        }
        .math-mode #q-hint-box {
            margin-top: 0.5rem !important;
            padding: 0.6rem 0.8rem !important;
            flex-direction: column;
            gap: 0.5rem;
            max-height: clamp(7rem, 32vh, 12rem);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
        }
        .math-mode #q-hint-box span {
            display: none;
        }
        .clock-mode.math-mode #q-hint-box {
            max-height: none;
            overflow: visible;
            min-height: 7.5rem;
            padding: 0.8rem 1rem !important;
        }
        .clock-mode.math-mode #q-hint {
            font-size: clamp(0.85rem, 2.5vw, 1rem);
            letter-spacing: 0;
        }

        .area-mode #q-hint {
            display: block;
            font-size: 0.95rem;
            letter-spacing: 0;
            color: #4b5563;
        }
        .area-mode #q-hint-box span {
            display: none;
        }
        .area-mode #q-grid {
            display: flex;
            max-width: 100%;
        }
        .area-mode #q-hint-box {
            flex-direction: column;
            gap: 0.5rem;
            max-height: clamp(7rem, 32vh, 12rem);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
        }

        .combo-bar {
            height: 0.5rem;
            background: rgba(251, 146, 60, 0.18);
            border-radius: 999px;
            overflow: hidden;
        }
        .combo-fill {
            height: 100%;
            width: 0%;
            background: #fb923c;
            transition: width 0.35s ease;
        }
        #scene-study {
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch;
        }
        #scene-study.writing-mode .study-card-wrap {
            height: 20rem;
            margin-bottom: 1.25rem;
        }
        #scene-study.writing-mode #writing-area {
            margin-top: 0.5rem;
        }
        #scene-study.writing-mode #study-controls {
            margin-bottom: 1.5rem;
        }

        #start-screen, #scene-reward, #scene-shop, #scene-synthesis {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
        }

        /* é­”ç‹æˆ°å ´æ™¯èƒŒæ™¯ */
        #scene-boss {
            background: linear-gradient(135deg, #2c0e37 0%, #000000 100%);
            z-index: 9998;
            pointer-events: auto;
            touch-action: manipulation;
            isolation: isolate;
        }
        #scene-boss * {
            pointer-events: auto;
        }

        /* iPad æ•ˆèƒ½å„ªåŒ– */
        @supports (-webkit-touch-callout: none) {
            * {
                backdrop-filter: none !important;
                -webkit-backdrop-filter: none !important;
            }
            #start-screen, #scene-reward, #scene-shop, #scene-synthesis, #scene-menu .bg-white {
                background: rgba(255, 255, 255, 0.98) !important;
            }
            .bg-white\/90, .bg-white\/80 {
                background: rgba(255, 255, 255, 0.95) !important;
            }
            html, body {
                position: relative;
                height: var(--app-height);
                width: var(--app-width);
            }
        }
    </style>
</head>
<body class="w-screen flex flex-col items-center justify-center text-gray-800">

    <!-- éŸ³æ•ˆè³‡æºåº« -->
    <audio id="bgm" preload="auto"></audio>
    <audio id="sfx-correct" preload="auto" src="https://assets.mixkit.co/sfx/download/mixkit-extra-bonus-in-a-video-game-2045.wav"></audio>
    <audio id="sfx-wrong" preload="auto" src="https://assets.mixkit.co/sfx/download/mixkit-game-show-wrong-answer-buzz-950.wav"></audio>
    <audio id="sfx-meow" preload="auto" src="sound/meow1.mp3"></audio>
    <audio id="sfx-real-meow" preload="auto" src="sound/meow2.mp3"></audio>
    <audio id="sfx-angry" preload="auto" src="sound/an1.mp3"></audio>
    <audio id="sfx-levelup" preload="auto" src="https://assets.mixkit.co/sfx/download/mixkit-quick-win-video-game-notification-269.wav"></audio>
    <audio id="sfx-chew" preload="auto" src="sound/chew.mp3"></audio>
    <audio id="sfx-coin" preload="auto" src="sound/coin.mp3"></audio>
    <audio id="sfx-clean" preload="auto" src="sound/clean.mp3"></audio>
    <audio id="sfx-diamond" preload="auto" src="sound/diamond.mp3"></audio>
    <audio id="sfx-pop" preload="auto" src="sound/pop.mp3"></audio>
    <audio id="sfx-spin" preload="auto" src="sound/spin.mp3"></audio>
    <audio id="sfx-don" preload="auto" src="sound/don-1.mp3"></audio>
    <audio id="sfx-don-2" preload="auto" src="sound/don-2.mp3"></audio>
    <audio id="sfx-combo-1" preload="auto" src="sound/combo1.mp3"></audio>
    <audio id="sfx-combo-2" preload="auto" src="sound/combo2.mp3"></audio>
    <audio id="sfx-combo-3" preload="auto" src="sound/combo3.mp3"></audio>
    <audio id="sfx-combo-4" preload="auto" src="sound/combo4.mp3"></audio>
    <audio id="sfx-flip" preload="auto" src="https://assets.mixkit.co/sfx/download/mixkit-paper-slide-1530.wav"></audio>
    <audio id="sfx-win" preload="auto" src="sound/winner-game.mp3"></audio>
    <audio id="sfx-treasure-step" preload="auto" src="https://assets.mixkit.co/sfx/download/mixkit-player-jumping-in-a-video-game-2043.wav"></audio>
    <audio id="sfx-treasure-push" preload="auto" src="https://assets.mixkit.co/sfx/download/mixkit-heavy-stone-slide-204.wav"></audio>
    <audio id="sfx-treasure-win" preload="auto" src="https://assets.mixkit.co/sfx/download/mixkit-winning-chimes-2015.wav"></audio>
    <audio id="sfx-treasure-ding" preload="auto" src="https://assets.mixkit.co/sfx/download/mixkit-bell-notification-933.wav"></audio>
    <audio id="sfx-boss-bgm" preload="auto" src="music/boss-1.mp3"></audio>
    <audio id="sfx-boss-hit" preload="auto" src="https://commondatastorage.googleapis.com/codeskulptor-assets/sounddogs/missile.mp3"></audio>
    <audio id="sfx-boss-heal" preload="auto" src="https://commondatastorage.googleapis.com/codeskulptor-assets/week7-bounce.m4a"></audio>
    <audio id="sfx-boss-appear" preload="auto" src="https://commondatastorage.googleapis.com/codeskulptor-assets/sounddogs/thrust.mp3"></audio>

    <!-- 0. å•Ÿå‹•ç•«é¢ -->
    <div id="start-screen" class="fixed inset-0 z-[100] flex flex-col items-center justify-center p-4">
        <div class="bg-white p-8 rounded-3xl shadow-2xl text-center max-w-sm w-full border-4 border-orange-300">
            <div class="text-6xl mb-4 animate-bounce">ğŸ±</div>
            <h1 class="text-3xl font-black text-gray-800 mb-2">è²“å’ªå°å­¸å ‚</h1>
            <p class="text-gray-500 mb-8">æº–å‚™å¥½å¹«è²“å’ªè³ºç½é ­äº†å—ï¼Ÿ</p>
            <button onclick="unlockAudioAndStart()" class="w-full btn-3d bg-orange-500 text-white text-xl font-bold py-4 rounded-xl border-b-4 border-orange-700 active:border-orange-500 mb-4">
                â–¶ï¸ é»æˆ‘é–‹å§‹éŠæˆ²
            </button>
            <button onclick="checkForUpdate()" class="w-full btn-3d bg-slate-100 text-slate-600 text-sm font-bold py-2 rounded-xl border-b-4 border-slate-200 active:border-slate-100 mb-3">
                ğŸ”„ æª¢æŸ¥æ›´æ–°
            </button>
            <div class="w-full text-left mb-3">
                <div class="text-xs text-gray-500 mb-1">é‚€è«‹ç¢¼å…Œæ›</div>
                <div class="flex gap-2">
                    <input type="text" id="invite-code" placeholder="è¼¸å…¥é‚€è«‹ç¢¼" class="flex-1 p-2 border-2 border-gray-200 rounded-lg text-sm focus:border-orange-400 focus:outline-none">
                    <button onclick="redeemInviteCode()" class="btn-3d px-3 py-2 bg-orange-400 text-white rounded-lg font-bold border-b-4 border-orange-600 text-sm">
                        å…Œæ›
                    </button>
                </div>
                <p id="invite-status" class="text-[11px] text-gray-400 mt-1"></p>
            </div>
            <button onclick="openKeySettings()" class="text-gray-400 text-xs underline hover:text-orange-500 transition">
                ğŸ”‘ è¨­å®š AI é‡‘é‘° (è®“è²“å’ªè®Šè°æ˜)
            </button>
            <p id="ai-status" class="mt-2 text-[11px] text-gray-400">AIï¼šå°šæœªè¨­å®š</p>
            <p class="mt-4 text-xs text-gray-400">è«‹ç¢ºèªå¹³æ¿è²éŸ³å·²é–‹å•Ÿ</p>
        </div>
    </div>

    <div id="scene-key-settings" class="hidden fixed inset-0 z-[200] flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm">
        <div class="bg-white w-full max-w-md rounded-3xl p-6 shadow-2xl border-4 border-gray-200">
            <h2 class="text-xl font-bold text-gray-700 mb-2">è¨­å®š Gemini API Key</h2>
            <p class="text-xs text-gray-400 mb-4">è¼¸å…¥ Key å¾Œï¼Œè²“å’ªæœƒæ ¹æ“šä½ çš„ç‹€æ³è·Ÿä½ èŠå¤©å–”ï¼<br>(Key åªæœƒå­˜åœ¨ä½ çš„ç€è¦½å™¨è£¡ï¼Œå¾ˆå®‰å…¨)</p>

            <input type="text" id="input-api-key" placeholder="è²¼ä¸Šä½ çš„ AIza... é‡‘é‘°" class="w-full p-3 border-2 border-gray-300 rounded-xl mb-4 text-sm focus:border-orange-400 focus:outline-none">
            <p id="api-key-status" class="text-[11px] text-gray-400 mb-3"></p>

            <div class="flex gap-2">
                <button onclick="saveApiKey()" class="flex-1 py-3 bg-green-500 text-white rounded-xl font-bold btn-3d border-b-4 border-green-700">å„²å­˜</button>
                <button onclick="closeKeySettings()" class="flex-1 py-3 bg-gray-400 text-white rounded-xl font-bold btn-3d border-b-4 border-gray-600">å–æ¶ˆ</button>
            </div>

            <div class="mt-4 text-[10px] text-gray-400 text-center">
                é‚„æ²’æœ‰ Key? <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-blue-400 underline">å» Google ç”³è«‹å…è²» Key</a>
            </div>
        </div>
    </div>

    <div id="scene-chat-input" class="hidden fixed inset-0 z-[200] flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm">
        <div class="bg-white w-full max-w-md rounded-3xl p-6 shadow-2xl border-4 border-teal-200">
            <h2 class="text-xl font-bold text-teal-600 mb-2">è·Ÿè²“å’ªèŠå¤©</h2>
            <p class="text-xs text-gray-400 mb-4">æ‰“ä¸€å¥è©±çµ¦å®ƒï¼ˆ20 å­—å…§æ›´å¯æ„›ï¼‰</p>

            <textarea id="input-chat-text" maxlength="60" rows="3" placeholder="ä¾‹å¦‚ï¼šä»Šå¤©å¥½é–‹å¿ƒï¼" class="w-full p-3 border-2 border-gray-200 rounded-2xl text-sm focus:border-teal-400 focus:outline-none resize-none"></textarea>

            <div class="flex gap-2 mt-4">
                <button onclick="submitChatInput()" class="flex-1 py-3 bg-teal-500 text-white rounded-xl font-bold btn-3d border-b-4 border-teal-700">é€å‡º</button>
                <button onclick="closeChatInput()" class="flex-1 py-3 bg-gray-400 text-white rounded-xl font-bold btn-3d border-b-4 border-gray-600">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- 1. ä¸»ç•«é¢ (æˆ¿é–“) -->
    <div id="scene-room" class="w-full max-w-md h-full flex flex-col p-4 relative hidden opacity-0 transition-opacity duration-500">
        <div id="room-atmosphere" class="absolute inset-0 w-full h-full pointer-events-none z-0"></div>
        <div id="room-decorations" class="absolute inset-0 w-full h-full pointer-events-none z-0">
            <div id="decor-window" class="decor-item hidden">ğŸ–¼ï¸</div>
            <div id="decor-rug" class="decor-item hidden">ğŸŒˆ</div>
            <div id="decor-toy" class="decor-item hidden">ğŸ§¶</div>
            <div id="decor-plant" class="decor-item hidden">ğŸŒ¿</div>
            <div id="decor-lamp" class="decor-item hidden">ğŸ®</div>
            <div id="decor-balloon" class="decor-item hidden">ğŸˆ</div>
        </div>
        <div id="poop-layer" class="absolute inset-0 w-full h-full z-[20] pointer-events-none"></div>
        
        <!-- é ‚éƒ¨è³‡è¨Šåˆ— -->
        <div class="flex justify-between items-center bg-white/90 backdrop-blur-sm p-3 rounded-2xl shadow-lg mb-2 border-2 border-white z-10">
            <div class="flex items-center gap-2 min-w-fit">
                <span class="text-2xl">ğŸ†</span>
                <span class="font-bold text-lg">Lv.<span id="ui-level">1</span></span>
            </div>
            
            <div class="flex-1 mx-3 flex flex-col justify-center">
                <!-- é€™è£¡è£œå›äº†é¡¯ç¤ºç¶“é©—å€¼çš„æ–‡å­—å€å¡Š -->
                <div class="flex justify-between text-xs text-gray-500 mb-1 px-1">
                    <span>EXP</span>
                    <span id="ui-exp-text">0/10</span>
                </div>
                <!-- é€²åº¦æ¢ -->
                <div class="w-full bg-gray-200 rounded-full h-3 overflow-hidden border border-gray-300">
                    <div id="ui-exp-bar" class="exp-fill bg-green-400 h-full shadow-[0_0_10px_rgba(74,222,128,0.5)]" style="width: 0%"></div>
                </div>
            </div>

            <div class="flex items-center gap-2">
                <button id="btn-music" onclick="toggleMusic()" class="p-2 bg-gray-100 rounded-full text-sm hover:bg-gray-200 transition">
                    ğŸ”Š
                </button>
                <div class="decor-quick">
                    <button class="decor-slot" data-slot="0" onclick="openDecorPicker(0)">+</button>
                    <button class="decor-slot" data-slot="1" onclick="openDecorPicker(1)">+</button>
                    <button class="decor-slot" data-slot="2" onclick="openDecorPicker(2)">+</button>
                    <button class="decor-slot" data-slot="3" onclick="openDecorPicker(3)">+</button>
                </div>
            </div>

            <div class="flex items-center gap-1 bg-yellow-100 px-3 py-1 rounded-xl border border-yellow-200 shadow-sm min-w-fit">
                <span class="text-xl">ğŸ¥«</span>
                <span id="ui-food" class="font-bold text-orange-600">0</span>
            </div>
        </div>

        <div class="grid grid-cols-3 gap-2 mb-2 px-1 relative z-10">
            <div class="rounded-2xl border border-orange-100 bg-white/80 backdrop-blur-sm p-2 shadow-sm">
                <div class="flex items-center justify-between text-[11px] font-bold text-orange-600">
                    <span class="flex items-center gap-1"><span class="text-base">ğŸ—</span>é£½é£Ÿ</span>
                    <span id="ui-satiety-text" class="text-orange-500">100%</span>
                </div>
                <div class="mt-1 h-2.5 bg-orange-100 rounded-full overflow-hidden">
                    <div id="ui-satiety-bar" class="h-full bg-gradient-to-r from-orange-400 to-orange-500 transition-all duration-500" style="width: 100%"></div>
                </div>
            </div>
            <div class="rounded-2xl border border-pink-100 bg-white/80 backdrop-blur-sm p-2 shadow-sm">
                <div class="flex items-center justify-between text-[11px] font-bold text-pink-600">
                    <span class="flex items-center gap-1"><span class="text-base">â¤ï¸</span>å¿ƒæƒ…</span>
                    <span id="ui-mood-text" class="text-pink-500">100%</span>
                </div>
                <div class="mt-1 h-2.5 bg-pink-100 rounded-full overflow-hidden">
                    <div id="ui-mood-bar" class="h-full bg-gradient-to-r from-pink-400 to-pink-500 transition-all duration-500" style="width: 100%"></div>
                </div>
            </div>
            <div class="rounded-2xl border border-sky-100 bg-white/80 backdrop-blur-sm p-2 shadow-sm">
                <div class="flex items-center justify-between text-[11px] font-bold text-sky-600">
                    <span class="flex items-center gap-1"><span class="text-base">âœ¨</span>æ¸…æ½”</span>
                    <span id="ui-clean-text" class="text-sky-500">100%</span>
                </div>
                <div class="mt-1 h-2.5 bg-sky-100 rounded-full overflow-hidden">
                    <div id="ui-clean-bar" class="h-full bg-gradient-to-r from-sky-400 to-sky-500 transition-all duration-500" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <div id="status-sick" class="hidden absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-5xl animate-pulse z-30 pointer-events-none drop-shadow-lg">
            ğŸ˜·
        </div>
        <div id="status-hungry" class="hidden absolute top-20 right-10 text-3xl animate-bounce z-30 pointer-events-none drop-shadow-md">
            ğŸ½ï¸
        </div>

        <div id="decor-picker" class="hidden">
            <div class="flex items-center justify-between mb-2">
                <div class="text-sm font-bold text-indigo-600">é¸æ“‡è£é£¾</div>
                <button onclick="closeDecorPicker()" class="text-xs text-gray-400">é—œé–‰</button>
            </div>
            <div id="decor-picker-list" class="grid grid-cols-4 gap-2"></div>
        </div>

        <!-- è²“å’ªäº’å‹•å€ -->
        <div id="cat-zone" class="flex-1 flex flex-col items-center justify-center relative min-h-0 z-10">
            <div id="cat-container" class="relative cursor-pointer cat-walk" onclick="petCat(event)">
                <div id="cat-float" class="cat-float cat-anim">
                    <div id="cat-body" class="cat-body">
                        <img id="cat-image" src="https://robohash.org/egg?set=set4&size=250x250" class="w-64 h-64 max-h-[40vh] object-contain drop-shadow-2xl" alt="Cat">
                        <div id="synth-stack" class="synth-stack"></div>
                        <div id="gene-overlay" class="gene-overlay hidden">
                            <div class="gene-fusion-stage">
                                <div id="gene-overlay-left" class="gene-fusion-emoji left">ğŸ¤©</div>
                                <div id="gene-overlay-right" class="gene-fusion-emoji right">ğŸ˜º</div>
                                <div class="gene-fusion-tape"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="cat-speech" class="absolute -top-10 right-0 bg-white p-3 rounded-2xl rounded-bl-none shadow-md text-sm hidden font-bold text-gray-600 animate-bounce">
                    å–µå‘œï½
                </div>
            </div>
            <p class="mt-4 text-gray-500 text-sm bg-white/60 px-6 py-2 rounded-full backdrop-blur-sm shadow-sm animate-pulse">ğŸ‘† é»æ“Šè²“å’ªäº’å‹•</p>
        </div>

        <!-- æ§åˆ¶æŒ‰éˆ•å€ -->
        <div class="flex items-stretch gap-3 mt-2 mb-4 shrink-0 z-10">
            <div class="flex flex-col gap-2">
                <button onclick="feedCat(event)" class="btn-3d bg-orange-300 hover:bg-orange-400 text-white py-2 px-3 rounded-xl text-sm font-bold flex items-center gap-2 border-b-4 border-orange-500">
                    ğŸŸ <span>é¤µé£Ÿ</span>
                </button>
                <button onclick="cleanPoop()" class="btn-3d bg-emerald-300 hover:bg-emerald-400 text-white py-2 px-3 rounded-xl text-sm font-bold flex items-center gap-2 border-b-4 border-emerald-500">
                    ğŸ§¹ <span>æ¸…ç†</span>
                </button>
                <button onclick="openBath()" class="btn-3d bg-cyan-300 hover:bg-cyan-400 text-white py-2 px-3 rounded-xl text-sm font-bold flex items-center gap-2 border-b-4 border-cyan-500">
                    ğŸ› <span>æ´—æ¾¡</span>
                </button>
            </div>

            <div class="flex-1 grid grid-cols-2 gap-3">
                <button onclick="openMenu()" class="btn-3d bg-blue-500 hover:bg-blue-600 text-white py-4 rounded-2xl text-base font-black flex flex-col items-center justify-center gap-1 border-b-4 border-blue-700">
                    <span>âœï¸ å»æ‰“å·¥</span>
                    <span class="text-xs opacity-80">è³ºç½é ­</span>
                </button>
                <button id="btn-voice-chat" onclick="handleChatButton()" class="btn-3d bg-teal-500 hover:bg-teal-600 text-white py-4 rounded-2xl text-base font-black flex flex-col items-center justify-center gap-1 border-b-4 border-teal-700">
                    <span>ğŸ¤ èªªè©±</span>
                    <span class="text-xs opacity-80">é•·æŒ‰åˆ‡æ›æ–‡å­—</span>
                </button>
            </div>

            <div class="flex flex-col gap-2">
                <button onclick="openShop()" class="btn-3d bg-purple-300 hover:bg-purple-400 text-white py-2 px-3 rounded-xl text-sm font-bold flex items-center gap-2 border-b-4 border-purple-500">
                    ğŸ›’ <span>å•†åº—</span>
                </button>
                <button onclick="openSynthesis()" class="btn-3d bg-indigo-300 hover:bg-indigo-400 text-white py-2 px-3 rounded-xl text-sm font-bold flex items-center gap-2 border-b-4 border-indigo-500 relative">
                    ğŸ”® <span>åˆæˆ</span>
                    <div id="synth-badge" class="hidden absolute -top-2 -right-2 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center">!</div>
                </button>
                <button onclick="openCatBook()" class="btn-3d bg-amber-300 hover:bg-amber-400 text-white py-2 px-3 rounded-xl text-sm font-bold flex items-center gap-2 border-b-4 border-amber-500">
                    ğŸ“– <span>åœ–é‘‘</span>
                </button>
                <button onclick="openTreasureGame()" class="btn-3d bg-lime-300 hover:bg-lime-400 text-white py-2 px-3 rounded-xl text-sm font-bold flex items-center gap-2 border-b-4 border-lime-500">
                    ğŸ§© <span>è—å¯¶</span>
                </button>
                <button onclick="openBackyard()" class="btn-3d bg-pink-300 hover:bg-pink-400 text-white py-2 px-3 rounded-xl text-sm font-bold flex items-center gap-2 border-b-4 border-pink-500">
                    ğŸ¡ <span>è²“å’ªå±‹</span>
                </button>
            </div>
        </div>
    </div>

    <!-- 2. é¸èª²é¸å–® -->
    <div id="scene-menu" class="hidden fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4">
        <div class="bg-white w-full max-w-md rounded-3xl p-6 shadow-2xl animate-[fadeIn_0.3s_ease-out] border-4 border-blue-200 flex flex-col max-h-[90dvh]">
            <h2 class="text-2xl font-black text-center mb-4 text-gray-700 flex items-center justify-center gap-2 shrink-0">
                <span>ğŸ“š</span> é¸æ“‡èª²ç¨‹
            </h2>
            <div class="grid grid-cols-2 gap-3 overflow-y-auto p-1 flex-1 allow-scroll" id="lesson-list">
                <!-- JS ç”ŸæˆæŒ‰éˆ• -->
            </div>
            <button onclick="closeMenu()" class="mt-4 w-full py-3 bg-gray-400 hover:bg-gray-500 text-white rounded-xl font-bold btn-3d border-b-4 border-gray-600 shrink-0">è¿”å›æˆ¿é–“</button>
        </div>
    </div>

    <!-- å•†åº— -->
    <div id="scene-shop" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4">
        <div class="bg-white w-full max-w-md rounded-3xl p-6 shadow-2xl animate-[fadeIn_0.3s_ease-out] border-4 border-purple-200 flex flex-col max-h-[90dvh]">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-2xl font-black text-purple-600 flex items-center gap-2">
                    <span>ğŸ›’</span> å®¶å…·å•†åº—
                </h2>
                <div class="bg-yellow-100 px-3 py-1 rounded-full text-orange-600 font-bold border border-yellow-300">
                    ğŸ¥« <span id="shop-food-display">0</span>
                </div>
            </div>
            <div class="overflow-y-auto flex-1 p-1 space-y-3 allow-scroll" id="shop-list">
                <!-- JS ç”Ÿæˆå•†å“ -->
            </div>
            <button onclick="closeShop()" class="mt-4 w-full py-3 bg-gray-400 hover:bg-gray-500 text-white rounded-xl font-bold btn-3d border-b-4 border-gray-600 shrink-0">é›¢é–‹å•†åº—</button>
        </div>
    </div>

    <!-- åˆæˆ/æ”¶è— -->
    <div id="scene-synthesis" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4">
        <div class="bg-white w-full max-w-md rounded-3xl p-4 shadow-2xl animate-[fadeIn_0.3s_ease-out] border-4 border-indigo-200 flex flex-col max-h-[88dvh] overflow-hidden">
            <h2 class="text-2xl font-black text-indigo-600 mb-2 text-center">ğŸ”® åˆæˆå·¥åŠ</h2>
            <div class="flex mb-4 bg-gray-100 p-1 rounded-lg">
                <button onclick="switchSynthesisTab('synth-tab-craft')" id="btn-synth-tab-craft" class="flex-1 py-2 rounded-md font-bold text-sm bg-white shadow-sm text-indigo-600 transition">ğŸ§ª åˆæˆ</button>
                <button onclick="switchSynthesisTab('synth-tab-collection')" id="btn-synth-tab-collection" class="flex-1 py-2 rounded-md font-bold text-sm text-gray-400 hover:bg-white/50 transition">ğŸ“– æ”¶è—</button>
                <button onclick="switchSynthesisTab('synth-tab-gene')" id="btn-synth-tab-gene" class="flex-1 py-2 rounded-md font-bold text-sm text-gray-400 hover:bg-white/50 transition">ğŸª„ Majicå·¥åŠ</button>
            </div>

            <div id="synth-tab-craft" class="flex-1 min-h-0 flex flex-col overflow-y-auto pr-1 allow-scroll">
                <div class="flex items-center justify-center gap-3 mb-3 bg-indigo-50 p-3 rounded-xl">
                    <div class="relative w-20 h-20 rounded-2xl bg-white border border-indigo-200 flex items-center justify-center text-3xl">
                        ğŸ±
                        <div id="synth-preview" class="synth-stack"></div>
                    </div>
                    <div class="text-2xl text-indigo-300">+</div>
                    <div id="craft-slot" class="w-16 h-16 border-2 border-dashed border-indigo-300 rounded-xl flex items-center justify-center text-4xl bg-white cursor-pointer" onclick="resetCraftSlot()">â“</div>
                    <div class="text-2xl text-indigo-300">=</div>
                    <button id="btn-synthesize" onclick="doSynthesis()" class="px-4 py-2 bg-gray-300 text-white rounded-lg font-bold shadow-sm" disabled>åˆæˆ</button>
                </div>
                <p id="synth-msg" class="text-xs text-gray-500 mb-2 text-center"></p>
                <p class="text-xs text-gray-400 mb-2">é»é¸ç´ æé€²è¡Œåˆæˆï¼š</p>
                <div id="material-list" class="grid grid-cols-4 gap-2 content-start p-1">
                    <!-- JS ç”Ÿæˆç´ æ -->
                </div>
            </div>

            <div id="synth-tab-collection" class="hidden flex-1 min-h-0 overflow-y-auto grid grid-cols-2 gap-3 p-1 content-start pr-1 allow-scroll">
                <!-- JS ç”Ÿæˆæ”¶è— -->
            </div>

            <div id="synth-tab-gene" class="hidden flex-1 min-h-0 flex flex-col overflow-y-auto pr-1 allow-scroll">
                <div class="rounded-3xl bg-gradient-to-br from-slate-900 via-indigo-900 to-slate-950 text-white p-4 border border-white/10 shadow-[0_20px_60px_rgba(15,23,42,0.45)] mb-4">
                    <div class="flex items-start justify-between gap-3">
                        <div>
                            <p class="text-[10px] uppercase tracking-[0.25em] text-slate-300">Majic Lab</p>
                            <h3 id="gene-name" class="text-lg font-black text-white">ç”œç”œå°å–µ #001</h3>
                            <p id="gene-desc" class="text-xs text-slate-300">é–ƒé–ƒç™¼äº®ã€‚</p>
                        </div>
                        <button onclick="randomGeneMutation()" class="px-3 py-2 bg-gradient-to-r from-sky-400 to-indigo-400 text-slate-900 rounded-lg font-bold text-sm btn-3d">
                            ğŸ² é©šå–œé­”æ³•
                        </button>
                    </div>
                    <p class="text-[11px] text-slate-300 mt-2">ç´ æå–å¾—ï¼šå®Œæˆé—œå¡æˆ– Boss æœƒæ‰è½ã€‚</p>

                    <div class="mt-4 flex flex-col sm:flex-row gap-4 items-center">
                        <div class="relative w-40 h-40 rounded-full bg-slate-950/80 border border-white/10 shadow-[inset_0_0_45px_rgba(0,0,0,0.6)] flex items-center justify-center">
                            <div class="absolute inset-0 rounded-full bg-gradient-to-br from-sky-500/20 via-indigo-500/20 to-transparent blur-2xl"></div>
                            <div class="gene-fusion-stage">
                                <div id="gene-fusion-left" class="gene-fusion-emoji left">ğŸ¤©</div>
                                <div id="gene-fusion-right" class="gene-fusion-emoji right">ğŸ˜º</div>
                                <div class="gene-fusion-tape"></div>
                            </div>
                        </div>

                        <div class="flex-1 w-full space-y-2">
                            <div class="flex items-center justify-between rounded-2xl bg-white/10 px-3 py-2 border border-white/10">
                                <div class="flex items-center gap-2 text-sm text-sky-100">
                                    <span>ğŸ‘ï¸</span>
                                    <span>çœ¼ç¥ç´ æ</span>
                                </div>
                                <div id="gene-eye-slot" class="text-2xl">ğŸ¤©</div>
                            </div>
                            <div class="flex items-center justify-between rounded-2xl bg-white/10 px-3 py-2 border border-white/10">
                                <div class="flex items-center gap-2 text-sm text-pink-100">
                                    <span>ğŸ‘„</span>
                                    <span>å˜´å·´ç´ æ</span>
                                </div>
                                <div id="gene-mouth-slot" class="text-2xl">ğŸ˜º</div>
                            </div>
                            <div class="rounded-2xl bg-white/5 px-3 py-2 border border-white/10">
                                <div class="flex justify-between text-xs text-slate-200 mb-1">
                                    <span>å½©è‰²é­”æ³•</span>
                                    <span id="gene-hue-val">0Â°</span>
                                </div>
                                <input id="gene-hue-slider" type="range" min="0" max="360" value="0" class="w-full accent-sky-400">
                            </div>
                            <div class="rounded-2xl bg-white/5 px-3 py-2 border border-white/10">
                                <div class="flex justify-between text-xs text-slate-200 mb-1">
                                    <span>æŸ”ç„¦é­”æ³•</span>
                                    <span id="gene-blur-val">0</span>
                                </div>
                                <input id="gene-blur-slider" type="range" min="0" max="8" step="0.5" value="0" class="w-full accent-pink-400">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="flex items-center gap-2 mb-3">
                    <button id="gene-tab-eyes" class="gene-tab active" onclick="switchGeneTab('eyes')">ğŸ‘ï¸ çœ¼ç¥</button>
                    <button id="gene-tab-mouth" class="gene-tab" onclick="switchGeneTab('mouth')">ğŸ‘„ å˜´å·´</button>
                </div>

                <div id="gene-panel-eyes" class="mb-4">
                    <div class="text-xs text-slate-500 mb-2">é¸æ“‡çœ¼ç¥ç´ æ</div>
                    <div id="gene-eyes-panel" class="grid grid-cols-5 gap-2"></div>
                </div>
                <div id="gene-panel-mouth" class="hidden mb-4">
                    <div class="text-xs text-slate-500 mb-2">é¸æ“‡å˜´å·´ç´ æ</div>
                    <div id="gene-mouth-panel" class="grid grid-cols-5 gap-2"></div>
                </div>

                <div class="flex gap-2 mb-4">
                    <button onclick="saveGeneMutation()" id="btn-save-gene" class="flex-1 py-2 bg-indigo-600 text-white rounded-lg font-bold btn-3d">ğŸ’¾ æ”¶è—é€ å‹</button>
                    <button onclick="resetGeneMutation()" class="flex-1 py-2 bg-gray-200 text-gray-600 rounded-lg font-bold">æ¸…ç©º</button>
                </div>

                <div class="text-xs text-gray-400 mb-1">æˆ‘çš„é­”æ³•æ”¶è—ï¼š</div>
                <div id="gene-collection-list" class="grid grid-cols-2 gap-2 p-1 content-start"></div>
            </div>

            <button onclick="closeSynthesis()" class="mt-4 w-full py-3 bg-gray-400 hover:bg-gray-500 text-white rounded-xl font-bold btn-3d border-b-4 border-gray-600 shrink-0">è¿”å›æˆ¿é–“</button>
        </div>
    </div>

    <!-- æ´—æ¾¡ -->
    <div id="scene-bath" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4 bg-cyan-900/40 backdrop-blur-sm">
        <div class="bg-white w-full max-w-md rounded-3xl p-6 shadow-2xl border-4 border-cyan-200 flex flex-col gap-4">
            <div class="flex items-center justify-between">
                <h2 class="text-2xl font-black text-cyan-600 flex items-center gap-2">
                    <span>ğŸ›</span> æ´—æ¾¡æ™‚é–“
                </h2>
                <button onclick="closeBath()" class="text-xs text-gray-400 hover:text-cyan-500">é—œé–‰</button>
            </div>
            <p class="text-xs text-gray-500">ç”¨æ°´æ²–æ´—ç´°èŒï¼Œé‚„éœ€è¦ <span id="bath-remaining" class="font-bold text-cyan-600">10</span> å€‹ã€‚</p>
            <div id="bath-zone" class="bath-zone"></div>
            <button onclick="closeBath()" class="w-full py-3 bg-gray-400 hover:bg-gray-500 text-white rounded-xl font-bold btn-3d border-b-4 border-gray-600">å®Œæˆå›æˆ¿é–“</button>
        </div>
    </div>

    <!-- è²“å’ªåœ–é‘‘ -->
    <div id="scene-catbook" class="hidden fixed inset-0 z-50 flex flex-col items-center justify-center p-4 bg-black/60 backdrop-blur-sm">
        <div class="bg-white w-full max-w-md rounded-3xl shadow-2xl border-4 border-amber-200 flex flex-col max-h-[85dvh] overflow-hidden">
            <div class="bg-amber-50 p-4 border-b-2 border-amber-200 flex justify-between items-center">
                <h2 class="text-2xl font-black text-amber-600 flex items-center gap-2">ğŸ“– è²“å’ªåœ–é‘‘</h2>
                <div class="text-xs font-bold text-amber-600 bg-white px-2 py-1 rounded-lg shadow-sm border border-amber-200">
                    æ”¶é›†é€²åº¦: <span id="catbook-progress">0/0</span>
                </div>
            </div>
            <div id="catbook-list" class="flex-1 min-h-0 overflow-y-auto grid grid-cols-3 gap-3 p-4 content-start bg-gray-50 allow-scroll"></div>
            <div class="p-4 border-t-2 border-gray-100 bg-white">
                <button onclick="closeCatBook()" class="w-full py-3 bg-gray-400 hover:bg-gray-500 text-white rounded-xl font-bold btn-3d border-b-4 border-gray-600 transition">é—œé–‰åœ–é‘‘</button>
            </div>
        </div>
    </div>

    <!-- è—å¯¶å°éŠæˆ² -->
    <div id="scene-treasure" class="hidden fixed inset-0 z-50 flex flex-col items-center justify-start p-4 pt-6 pb-6 text-white overflow-y-auto allow-scroll">
        <div id="treasure-backdrop" class="absolute inset-0 bg-slate-900/95 pointer-events-none"></div>
        <div class="treasure-scanline"></div>
        <div class="relative w-full max-w-md flex items-center justify-between mb-3 gap-2">
            <div>
                <div class="text-xs text-slate-400">è²“å’ªè—å¯¶æ¨¡å¼</div>
                <div class="text-lg font-black">ğŸ§© è²“å’ªè—å¯¶</div>
            </div>
            <div class="flex items-center gap-2 flex-wrap justify-end">
                <div class="px-3 py-1 rounded-lg bg-white text-xs font-bold text-slate-800 border border-slate-200">
                    ğŸŸï¸ <span id="treasure-ticket-count">0</span>
                </div>
                <button onclick="treasureGenerateLevel()" class="px-3 py-1 rounded-lg bg-white text-xs font-bold text-slate-800 hover:bg-slate-100 border border-slate-200">ğŸ”„ è·³é</button>
                <button onclick="closeTreasureGame()" class="px-3 py-1 rounded-lg bg-white text-xs font-bold text-slate-800 hover:bg-slate-100 border border-slate-200">è¿”å›æˆ¿é–“</button>
            </div>
        </div>

        <div class="relative w-full max-w-md mb-3 px-1">
            <div class="flex justify-between items-end mb-1">
                <h2 id="treasure-title" class="text-xl font-bold text-white tracking-wide">æœªçŸ¥é ˜åŸŸ</h2>
                <div class="text-xs text-slate-300 bg-white/10 px-2 py-1 rounded">Lv.<span id="treasure-level">1</span></div>
            </div>
            <p id="treasure-story" class="text-xs text-slate-300 min-h-[2.5em] leading-relaxed opacity-80">è²“å’ªæ­£åœ¨å°‹æ‰¾è—å¯¶è·¯ç·š...</p>
        </div>

        <div class="relative">
            <canvas id="treasure-canvas" class="treasure-canvas" width="396" height="396"></canvas>

            <div id="treasure-mask" class="hidden absolute inset-0 bg-black/80 flex flex-col items-center justify-center rounded-2xl z-20 backdrop-blur-sm">
                <div class="text-5xl mb-4 animate-spin">ğŸ’ </div>
                <div class="text-yellow-300 text-sm font-bold mb-1">è²“å’ªæ­£åœ¨æ—…è¡Œä¸­...</div>
                <div id="treasure-ai-status" class="text-blue-200 text-xs font-mono">è¦åˆ°å“ªè£¡å»å‘¢...</div>
            </div>

            <div id="treasure-win" class="hidden absolute inset-0 bg-black/60 backdrop-blur-md flex flex-col items-center justify-center rounded-2xl z-30">
                <div class="text-6xl mb-2 animate-bounce">ğŸ‰</div>
                <div class="text-xl font-bold text-yellow-300 mb-2">è—å¯¶æˆåŠŸï¼</div>
                <p id="treasure-win-comment" class="text-white/80 text-xs px-8 text-center mb-4">è²“å’ªæŠŠå¯¶è—è—å¥½äº†ï¼</p>
                <div class="treasure-wheel-wrap">
                    <div id="treasure-win-reward" class="absolute -top-10 left-1/2 -translate-x-1/2 text-base font-black text-yellow-200 hidden">
                        ç²å¾— 0 ç½é ­ï¼
                    </div>
                    <div id="treasure-wheel" class="treasure-wheel">
                        <div id="treasure-wheel-labels" class="treasure-wheel-labels"></div>
                    </div>
                    <div class="treasure-wheel-pointer"></div>
                </div>
                <div class="mt-4 flex gap-2">
                    <button id="treasure-spin-btn" onclick="spinTreasureRoulette()" class="btn-3d bg-yellow-400 border-b-4 border-yellow-600 text-slate-900 px-6 py-2 rounded-xl font-bold shadow-lg">
                        ğŸ¡ é–‹å§‹æŠ½ç
                    </button>
                    <button id="treasure-next-btn" onclick="treasureGenerateLevel()" class="btn-3d bg-green-500 border-b-4 border-green-700 text-white px-6 py-2 rounded-xl font-bold shadow-lg hidden">
                        ä¸‹ä¸€å±¤ âœ
                    </button>
                </div>
            </div>
        </div>

        <div class="w-full max-w-[396px] mt-4 flex justify-between items-center text-xs font-bold">
            <span class="text-slate-300">è—å¯¶é€²åº¦</span>
            <span class="text-yellow-300" id="treasure-score">0/0</span>
        </div>
        <div class="w-full max-w-[396px] h-2 bg-slate-700 rounded-full mt-1 overflow-hidden">
            <div id="treasure-progress" class="h-full bg-yellow-400 transition-all duration-300" style="width: 0%"></div>
        </div>

        <div class="treasure-controls">
            <div class="treasure-control-panel">
                <div class="grid grid-cols-3 gap-2 w-full h-28">
                    <div></div>
                    <button class="treasure-dpad-btn" onpointerdown="treasureHandleInput(0, -1)">â¬†ï¸</button>
                    <div></div>
                    <button class="treasure-dpad-btn" onpointerdown="treasureHandleInput(-1, 0)">â¬…ï¸</button>
                    <button class="treasure-dpad-btn text-sm" onclick="treasureUndoMove()">â†©ï¸<br>å¾©åŸ</button>
                    <button class="treasure-dpad-btn" onpointerdown="treasureHandleInput(1, 0)">â¡ï¸</button>
                    <div></div>
                    <button class="treasure-dpad-btn" onpointerdown="treasureHandleInput(0, 1)">â¬‡ï¸</button>
                    <div></div>
                </div>
            </div>
        </div>
    </div>

    <!-- è²“å’ªå¾Œé™¢ -->
    <div id="scene-backyard" class="hidden fixed inset-0 z-50 overflow-hidden cursor-crosshair">
        <div class="absolute top-4 left-4 z-50 flex flex-col gap-2">
            <div class="flex flex-wrap gap-2 items-center">
                <button onclick="closeBackyard()" class="btn-3d px-4 py-2 bg-gray-500 text-white rounded-xl font-bold border-b-4 border-gray-700">
                    ğŸšª è¿”å›æˆ¿é–“
                </button>
                <div class="bg-white/90 px-3 py-2 rounded-xl border-2 border-orange-200 flex items-center gap-2 font-bold text-orange-600">
                    <span>ğŸŸï¸ é£¼æ–™åˆ¸:</span>
                    <span id="backyard-ticket-count">0</span>
                </div>
                <div class="bg-white/90 px-3 py-2 rounded-xl border-2 border-orange-200 flex items-center gap-2 font-bold text-orange-600">
                    <span>ğŸ¥« ç½é ­:</span>
                    <span id="backyard-food-count">0</span>
                </div>
            </div>
            <div class="bg-white/80 px-3 py-2 rounded-xl border border-orange-100 text-xs font-bold text-orange-700 shadow-sm w-[260px]">
                <div class="flex justify-between mb-1">
                    <span id="backyard-progress-text">é¤µé£½é€²åº¦ 0/0</span>
                    <span>æ»¿å°±æ‰éŒ¢</span>
                </div>
                <div class="h-2 bg-orange-100 rounded-full overflow-hidden">
                    <div id="backyard-progress-bar" class="h-full bg-orange-400 transition-all duration-300" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <div class="absolute bottom-4 left-1/2 -translate-x-1/2 z-50 text-gray-500 text-sm font-bold bg-white/60 px-4 py-1 rounded-full pointer-events-none">
            ğŸ‘† é»æ“Šç©ºç™½è™•é¤µé£Ÿ (æ¶ˆè€—é£¼æ–™åˆ¸) â€¢ æ»¿æ¢æ‰æœƒæ‰éŒ¢
        </div>

        <div id="backyard-stage" class="absolute inset-0 w-full h-full" onclick="dropKibble(event)"></div>
    </div>

    <!-- 3. æˆ°é¬¥ç•«é¢ -->
    <div id="scene-study" class="hidden fixed inset-0 bg-[#FFF3E0] z-40 flex flex-col items-center justify-start p-4 pt-5 pb-8 overflow-y-auto allow-scroll">
        <div class="w-full max-w-md flex justify-between items-center mb-4 px-2">
            <div class="text-gray-500 font-bold">ç¬¬ <span id="q-idx">1</span> é¡Œ</div>
            <button onclick="quitStudy()" class="text-gray-400 hover:text-red-500 font-bold px-3 py-1 rounded-lg hover:bg-red-50 transition">é€ƒè·‘ ğŸ³ï¸</button>
        </div>
        <div class="w-full max-w-md h-3 bg-gray-200 rounded-full mb-8 shadow-inner overflow-hidden">
            <div id="study-progress" class="h-full bg-blue-500 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
        <div class="w-full max-w-md mb-4">
            <div class="flex items-center justify-between text-xs font-bold text-orange-600 mb-1">
                <span id="combo-label">COMBO x0</span>
                <span id="combo-stage">0/3</span>
            </div>
            <div class="combo-bar">
                <div id="combo-fill" class="combo-fill"></div>
            </div>
        </div>
        <div id="study-speech" class="hidden fixed bottom-4 right-4 z-40 flex items-end gap-2">
            <div class="w-10 h-10 rounded-full border-2 border-white shadow-md bg-white/90 flex items-center justify-center overflow-hidden">
                <img id="study-cat-avatar" src="https://robohash.org/egg?set=set4&size=80x80" alt="Cat" class="w-full h-full object-cover">
            </div>
            <div id="study-speech-text" class="max-w-[60vw] bg-white/90 text-gray-700 text-sm font-bold px-3 py-2 rounded-2xl shadow-sm border border-blue-100"></div>
        </div>
        <div class="study-card-wrap perspective-1000 w-full max-w-xs h-96 cursor-pointer mb-8 relative group" onclick="flipCard()">
            <div id="tap-hint" class="absolute -right-4 top-1/2 z-10 animate-bounce bg-white/80 p-2 rounded-full shadow-lg pointer-events-none">ğŸ‘†</div>
            <div id="study-card" class="card-inner relative w-full h-full transform-style-3d shadow-xl rounded-3xl transition-all duration-500">
                <div class="absolute w-full h-full backface-hidden bg-white rounded-3xl flex flex-col items-center justify-center border-4 border-blue-200 shadow-lg p-4">
                    <span class="text-4xl mb-2 opacity-50">ğŸ”Š</span>
                    <h2 id="q-zhuyin" class="text-8xl font-black text-gray-800 tracking-widest my-2 select-none"></h2>
                    <div id="q-hint-box" class="mt-4 bg-blue-50 px-6 py-3 rounded-2xl border border-blue-100 flex items-center justify-center gap-2 w-full">
                        <span class="text-gray-400 text-sm absolute top-2 left-4">æç¤ºï¼š</span>
                        <p id="q-hint" class="text-3xl font-bold text-blue-600 tracking-widest"></p>
                        <div id="q-grid" class="area-grid-wrap hidden"></div>
                    </div>
                    <p class="text-gray-400 mt-4 text-xs">å¯«å®Œå¾Œé»æˆ‘ç¿»ç‰Œ</p>
                </div>
                <div class="absolute w-full h-full backface-hidden rotate-y-180 bg-blue-50 rounded-3xl flex flex-col items-center justify-center border-4 border-blue-400 shadow-lg p-4">
                    <h2 id="q-char" class="text-9xl font-black text-red-500 mb-2 font-[KaiTi] select-none"></h2>
                    <div class="flex flex-col items-center gap-2 w-full">
                         <p id="q-radical" class="text-lg bg-blue-200 text-blue-900 px-3 py-1 rounded-lg font-bold shadow-sm"></p>
                         <div class="w-full bg-white/50 rounded-xl py-2 mt-2">
                            <p id="a-word" class="text-2xl font-bold text-gray-700"></p>
                         </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="writing-area" class="hidden flex flex-col items-center mt-2 w-full">
            <div class="relative border-4 border-dashed border-gray-300 rounded-xl bg-white touch-none" style="width: 280px; height: 280px;">
                <div class="absolute inset-0 pointer-events-none opacity-20"
                     style="background: linear-gradient(45deg, transparent 49%, #ef4444 49%, #ef4444 51%, transparent 51%), linear-gradient(-45deg, transparent 49%, #ef4444 49%, #ef4444 51%, transparent 51%), linear-gradient(90deg, transparent 49%, #ef4444 49%, #ef4444 51%, transparent 51%), linear-gradient(0deg, transparent 49%, #ef4444 49%, #ef4444 51%, transparent 51%);">
                </div>
                <canvas id="write-canvas" width="280" height="280"></canvas>
            </div>
            <div class="flex gap-2 mt-2">
                <button onclick="clearCanvas()" class="px-3 py-1 bg-gray-200 rounded text-sm">æ¸…é™¤</button>
                <button onclick="togglePenColor()" class="px-3 py-1 bg-black text-white rounded text-sm" id="pen-btn">ç­†è‰²: é»‘</button>
            </div>
        </div>
        <div id="study-controls" class="hidden flex gap-4 w-full max-w-md animate-[fadeIn_0.5s_ease-out]">
            <button onclick="answer(false)" class="flex-1 py-4 bg-red-400 hover:bg-red-500 text-white rounded-2xl font-bold shadow-md transform transition active:scale-95 border-b-4 border-red-600 text-lg">âŒ å†ç·´ä¸€æ¬¡</button>
            <button onclick="answer(true)" class="flex-1 py-4 bg-green-400 hover:bg-green-500 text-white rounded-2xl font-bold shadow-md transform transition active:scale-95 border-b-4 border-green-600 text-lg">âœ… æˆ‘å¯«å°äº†</button>
        </div>
    </div>

    <!-- 4. é­”ç‹æˆ° -->
    <div id="scene-boss" class="hidden fixed inset-0 z-50 flex flex-col items-center justify-center p-4">
        <div class="w-full max-w-md flex items-center justify-between mb-2">
            <h2 class="text-white text-xl font-black animate-pulse">âš ï¸ éŒ¯å­—æ€ªç¸å‡ºç¾äº†ï¼</h2>
            <button onclick="quitStudy()" class="text-white/70 hover:text-white font-bold px-3 py-1 rounded-lg hover:bg-white/10 transition">æ’¤é€€ ğŸ³ï¸</button>
        </div>
        <div class="w-full max-w-md bg-gray-700 rounded-full h-6 border-2 border-white overflow-hidden relative mb-4">
            <div id="boss-hp-bar" class="hp-fill bg-red-600 h-full w-full"></div>
            <span class="absolute inset-0 flex items-center justify-center text-xs text-white font-bold">HP: <span id="boss-hp-text">100</span>/<span id="boss-hp-max">100</span></span>
        </div>

        <div class="flex-1 flex flex-col items-center justify-center relative w-full">
            <img id="boss-image" src="https://robohash.org/monster?set=set2&size=300x300" class="w-64 h-64 drop-shadow-[0_0_15px_rgba(255,0,0,0.8)] object-contain transition-transform">
            <div id="boss-effect" class="absolute text-6xl font-bold transition-all opacity-0" style="top:20%;"></div>
        </div>

        <div class="w-full max-w-md bg-white rounded-2xl p-4 shadow-2xl mt-4 border-4 border-red-500 relative">
            <div class="text-center">
                <p class="text-gray-500 text-sm mb-1">è«‹å¯«å‡ºé€™å€‹å­—ï¼Œå–µï½</p>
                <h2 id="boss-q-zhuyin" class="text-6xl font-black text-gray-800 my-2"></h2>
                <p id="boss-q-word" class="text-xl text-blue-600 font-bold"></p>
            </div>
            
            <div id="boss-answer-mask" class="absolute bottom-3 left-1/2 -translate-x-1/2 bg-gray-900/90 px-4 py-2 rounded-full flex items-center justify-center cursor-pointer transition-opacity z-10 shadow-lg" onclick="revealBossAnswer()">
                <p class="text-white text-base font-bold animate-bounce">ğŸ‘† é»æˆ‘çœ‹ç­”æ¡ˆæ”»æ“Š</p>
            </div>

            <div id="boss-answer-area" class="hidden mt-4 pt-4 border-t-2 border-gray-100 flex flex-col items-center">
                <h2 id="boss-a-char" class="text-6xl text-red-500 font-[KaiTi]"></h2>
                <div class="flex gap-2 mt-4 w-full">
                    <button onclick="attackBoss(false)" class="flex-1 py-3 bg-red-200 text-red-800 rounded-xl font-bold">æ²’å¯«å° (æ€ªç¸è£œè¡€)</button>
                    <button onclick="attackBoss(true)" class="flex-1 py-3 bg-red-600 text-white rounded-xl font-bold">å¯«å°äº† (ç™¼å°„ç«çƒ)</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 5. çµç®—çå‹µç•«é¢ -->
    <div id="scene-reward" class="hidden fixed inset-0 z-[9999] flex flex-col items-center justify-center p-4">
        <div class="bg-white p-8 rounded-3xl shadow-2xl text-center max-w-sm w-full border-4 border-yellow-300 relative">
            <h2 id="reward-title" class="text-4xl font-black text-yellow-500 mb-4 animate-bounce">ğŸ‰ æ­å–œéé—œï¼</h2>
            <div id="reward-icon" class="text-8xl mb-4">ğŸ¥«</div>
            <p class="text-2xl text-gray-700 mb-6 font-bold">ç²å¾—äº† <span id="reward-count" class="text-red-500 text-4xl">0</span> å€‹<span id="reward-type">ç½é ­</span></p>
            <p id="reward-extra" class="text-sm text-gray-500 mb-2 hidden"></p>
            <p id="reward-extra-majic" class="text-sm text-gray-500 mb-2 hidden"></p>
            <p id="reward-exp-info" class="text-sm text-gray-400 mb-4 hidden">ç²å¾— 50 é»ç¶“é©—å€¼ï¼</p>
            <button onclick="collectReward(event)" class="w-full btn-3d bg-green-500 text-white text-xl font-bold py-4 rounded-xl border-b-4 border-green-700 active:border-green-500" style="pointer-events: auto;">
                ğŸ’° æ”¶ä¸‹çå‹µå›å®¶
            </button>
        </div>
    </div>

    <!-- æ‰“å·¥æ‹‰éœ¸æŠ½ç -->
    <div id="scene-slot" class="hidden fixed inset-0 z-[9999] flex items-center justify-center p-4">
        <div class="absolute inset-0 bg-black/50 backdrop-blur-sm"></div>
        <div class="relative bg-white w-full max-w-sm rounded-3xl p-6 shadow-2xl border-4 border-yellow-200 text-center">
            <h2 class="text-2xl font-black text-yellow-500 mb-2">ğŸ° æ‰“å·¥æ‹‰éœ¸</h2>
            <p class="text-xs text-gray-500 mb-4">æœ¬æ¬¡æ‰“å·¥çå‹µï¼š<span id="slot-base-reward" class="font-bold text-gray-700">0</span> ç½é ­</p>
            <div class="slot-reels mb-4">
                <div class="slot-machine-window">
                    <div id="slot-reel-1" class="reel-strip"></div>
                </div>
                <div class="slot-machine-window">
                    <div id="slot-reel-2" class="reel-strip"></div>
                </div>
                <div class="slot-machine-window">
                    <div id="slot-reel-3" class="reel-strip"></div>
                </div>
            </div>
            <p id="slot-result" class="text-sm font-bold text-orange-500 mb-3 hidden">æŠ½åˆ° +3</p>
            <p class="text-[11px] text-gray-400 mb-4">å¯èƒ½çµæœï¼š30% æ§“é¾œã€+1~+6ã€æ°´æœåŠ ç¢¼ã€ä½æ©Ÿç‡ x2/x3/x5</p>
            <div class="flex gap-2">
                <button id="slot-spin-btn" onclick="spinWorkSlot()" class="flex-1 btn-3d bg-yellow-400 text-slate-900 font-bold py-3 rounded-xl border-b-4 border-yellow-600">é–‹å§‹æ‹‰éœ¸</button>
                <button id="slot-claim-btn" onclick="claimWorkSlot()" class="flex-1 btn-3d bg-green-500 text-white font-bold py-3 rounded-xl border-b-4 border-green-700 hidden">é ˜å–çå‹µ</button>
            </div>
        </div>
    </div>

    <!-- å‡ç´šç‰¹æ•ˆ -->
    <div id="levelup-overlay" class="hidden fixed inset-0 bg-black/80 z-[80] flex flex-col items-center justify-center text-white text-center pointer-events-none">
        <h1 class="text-7xl font-bold text-yellow-300 mb-4 animate-bounce drop-shadow-[0_5px_5px_rgba(0,0,0,0.5)]">LEVEL UP!</h1>
        <p class="text-3xl font-bold text-white mb-8">è²“å’ªé€²åŒ–äº†ï¼âœ¨</p>
        <div class="text-6xl animate-pulse">ğŸ˜»</div>
    </div>

<script>
    // --- 0. è³‡æ–™åº« ---
    const lessons = {
        "7": { title: "ç¬¬ä¸ƒèª²", category: "åœ‹èª", words: [
            {c:"æ¨£",z:"ã„§ã„¤Ë‹",r:"æœ¨éƒ¨",w:"æ¨£å­"}, {c:"é£Ÿ",z:"ã„•ËŠ",r:"é£Ÿéƒ¨",w:"é£Ÿå“"}, {c:"éƒŠ",z:"ã„ã„§ã„ ",r:"é‚‘éƒ¨",w:"éƒŠå¤–"}, {c:"æ´»",z:"ã„ã„¨ã„›ËŠ",r:"æ°´éƒ¨",w:"ç”Ÿæ´»"},
            {c:"å¥‡",z:"ã„‘ã„§ËŠ",r:"å¤§éƒ¨",w:"å¥‡æ€ª"}, {c:"ç­’",z:"ã„Šã„¨ã„¥Ë‡",r:"ç«¹éƒ¨",w:"ç«¹ç­’"}, {c:"é¦™",z:"ã„’ã„§ã„¤",r:"é¦™éƒ¨",w:"é¦™æ°´"}, {c:"å‘³",z:"ã„¨ã„ŸË‹",r:"å£éƒ¨",w:"å‘³é“"},
            {c:"ä¾¿",z:"ã„…ã„§ã„¢Ë‹",r:"äººéƒ¨",w:"æ–¹ä¾¿"}, {c:"ç•¶",z:"ã„‰ã„¤",r:"ç”°éƒ¨",w:"ä¾¿ç•¶"}, {c:"ç›’",z:"ã„ã„œËŠ",r:"çš¿éƒ¨",w:"ç›’å­"}, {c:"å®¢",z:"ã„ã„œË‹",r:"å®€éƒ¨",w:"å®¢äºº"},
            {c:"æ¸…",z:"ã„‘ã„§ã„¥",r:"æ°´éƒ¨",w:"æ¸…æ°´"}, {c:"ç¯€",z:"ã„ã„§ã„ËŠ",r:"ç«¹éƒ¨",w:"ç¯€æ—¥"}, {c:"ä¿",z:"ã„…ã„ Ë‡",r:"äººéƒ¨",w:"ä¿è­·"}, {c:"å¹³",z:"ã„†ã„§ã„¥ËŠ",r:"å¹²éƒ¨",w:"å¹³å®‰"},
            {c:"å®‰",z:"ã„¢",r:"å®€éƒ¨",w:"å®‰å…¨"}, {c:"å—",z:"ã„‹ã„¢ËŠ",r:"åéƒ¨",w:"å—æ–¹"}
        ]},
        "8": { title: "ç¬¬å…«èª²", category: "åœ‹èª", words: [
            {c:"ä»‹",z:"ã„ã„§ã„Ë‹",r:"äººéƒ¨",w:"ä»‹ç´¹"}, {c:"åœ’",z:"ã„©ã„¢ËŠ",r:"å›—éƒ¨",w:"å…¬åœ’"}, {c:"å½¢",z:"ã„’ã„§ã„¥ËŠ",r:"å½¡éƒ¨",w:"å½¢ç‹€"}, {c:"ç™½",z:"ã„…ã„ËŠ",r:"ç™½éƒ¨",w:"ç™½è‰²"},
            {c:"ç´™",z:"ã„“Ë‡",r:"ç³¸éƒ¨",w:"ç™½ç´™"}, {c:"ç±³",z:"ã„‡ã„§Ë‡",r:"ç±³éƒ¨",w:"ç™½ç±³"}, {c:"è®Š",z:"ã„…ã„§ã„¢Ë‹",r:"è¨€éƒ¨",w:"æ”¹è®Š"}, {c:"è»Ÿ",z:"ã„–ã„¨ã„¢Ë‡",r:"è»Šéƒ¨",w:"æŸ”è»Ÿ"},
            {c:"æ¶",z:"ã„‘ã„§ã„¤Ë‡",r:"æ‰‹éƒ¨",w:"æ¶èµ°"}, {c:"æ",z:"ã„˜ã„ËŠ",r:"æœ¨éƒ¨",w:"ææ–™"}, {c:"è¦",z:"ã„’ã„§ã„š",r:"è™«éƒ¨",w:"è¦å­"}, {c:"ç·š",z:"ã„’ã„§ã„¢Ë‹",r:"ç³¸éƒ¨",w:"æ¯›ç·š"},
            {c:"å„",z:"ã„ã„œË‹",r:"å£éƒ¨",w:"å„ç¨®"}, {c:"ç¨®",z:"ã„“ã„¨ã„¥Ë‡",r:"ç¦¾éƒ¨",w:"ç¨®å­"}, {c:"èœ",z:"ã„˜ã„Ë‹",r:"è‰¸éƒ¨",w:"é’èœ"}, {c:"è½",z:"ã„Šã„§ã„¥",r:"è€³éƒ¨",w:"è½è¦‹"},
            {c:"æ›´",z:"ã„ã„¥Ë‹",r:"æ›°éƒ¨",w:"æ›´åŠ "}, {c:"æ¥",z:"ã„ã„§ã„",r:"æ‰‹éƒ¨",w:"æ¥å—"}
        ]},
        "9": { title: "ç¬¬ä¹èª²", category: "åœ‹èª", words: [
            {c:"é»ƒ",z:"ã„ã„¨ã„¤ËŠ",r:"é»ƒéƒ¨",w:"é»ƒè‰²"}, {c:"æ²–",z:"ã„”ã„¨ã„¥",r:"æ°´éƒ¨",w:"æ²–æ´—"}, {c:"æ¾¡",z:"ã„—ã„ Ë‡",r:"æ°´éƒ¨",w:"æ´—æ¾¡"}, {c:"è˜¿",z:"ã„Œã„¨ã„›ËŠ",r:"è‰¸éƒ¨",w:"è˜¿è””"},
            {c:"è””",z:"ã„…ã„›Ë™",r:"è‰¸éƒ¨",w:"è˜¿è””"}, {c:"å“ª",z:"ã„‹ã„šË‡",r:"å£éƒ¨",w:"å“ªè£¡"}, {c:"ç²’",z:"ã„Œã„§Ë‹",r:"ç±³éƒ¨",w:"ç±³ç²’"}, {c:"ç†±",z:"ã„–ã„œË‹",r:"ç«éƒ¨",w:"ç†±é¬§"},
            {c:"æµ´",z:"ã„©Ë‹",r:"æ°´éƒ¨",w:"æµ´å®¤"}, {c:"è’¸",z:"ã„“ã„¥",r:"ç«éƒ¨",w:"è’¸æ°£"}, {c:"èƒ–",z:"ã„†ã„¤Ë‹",r:"è‚‰éƒ¨",w:"è‚¥èƒ–"}, {c:"å",z:"ã„‡ã„§ã„¥ËŠ",r:"å£éƒ¨",w:"åå­—"},
            {c:"è‹”",z:"ã„Šã„ËŠ",r:"è‰¸éƒ¨",w:"é’è‹”"}, {c:"è›‹",z:"ã„‰ã„¢Ë‹",r:"è™«éƒ¨",w:"é›è›‹"}, {c:"è”¬",z:"ã„•ã„¨",r:"è‰¸éƒ¨",w:"è”¬èœ"}, {c:"é€š",z:"ã„Šã„¨ã„¥",r:"è¾µéƒ¨",w:"é€šé"},
            {c:"ç´°",z:"ã„’ã„§Ë‹",r:"ç³¸éƒ¨",w:"ç´°å°"}
        ]},
        "10": { title: "ç¬¬åèª²", category: "åœ‹èª", words: [
            {c:"æ¸›",z:"ã„ã„§ã„¢Ë‡",r:"æ°´éƒ¨",w:"æ¸›å°‘"}, {c:"è¡¨",z:"ã„…ã„§ã„ Ë‡",r:"è¡£éƒ¨",w:"èª²è¡¨"}, {c:"è®€",z:"ã„‰ã„¨ËŠ",r:"è¨€éƒ¨",w:"è®€æ›¸"}, {c:"èª",z:"ã„–ã„£Ë‹",r:"è¨€éƒ¨",w:"èªè­˜"},
            {c:"è­˜",z:"ã„•Ë‹",r:"è¨€éƒ¨",w:"çŸ¥è­˜"}, {c:"è¬",z:"ã„‡ã„§ËŠ",r:"è¨€éƒ¨",w:"è¬é¡Œ"}, {c:"ç­”",z:"ã„‰ã„šËŠ",r:"ç«¹éƒ¨",w:"å›ç­”"}, {c:"æ–",z:"ã„§ã„ ËŠ",r:"æ‰‹éƒ¨",w:"æ–é ­"},
            {c:"ç™¾",z:"ã„…ã„Ë‡",r:"ç™½éƒ¨",w:"ä¸€ç™¾"}, {c:"å˜´",z:"ã„—ã„¨ã„ŸË‡",r:"å£éƒ¨",w:"å˜´å·´"}, {c:"å“¥",z:"ã„ã„œ",r:"å£éƒ¨",w:"å“¥å“¥"}, {c:"æ•¸",z:"ã„•ã„¨Ë‹",r:"æ”µéƒ¨",w:"æ•¸å­¸"},
            {c:"é¡Œ",z:"ã„Šã„§ËŠ",r:"é éƒ¨",w:"é¡Œç›®"}, {c:"è¶•",z:"ã„ã„¢Ë‡",r:"èµ°éƒ¨",w:"è¶•å¿«"}, {c:"çª",z:"ã„Šã„¨ËŠ",r:"ç©´éƒ¨",w:"çªç„¶"}, {c:"ç•°",z:"ã„§Ë‹",r:"ç”°éƒ¨",w:"å¥‡ç•°"},
            {c:"å£",z:"ã„ã„¡Ë‡",r:"å£éƒ¨",w:"å£è¢‹"}, {c:"å°",z:"ã„‰ã„¨ã„ŸË‹",r:"å¯¸éƒ¨",w:"å°éŒ¯"}
        ]},
        "11": { title: "ç¬¬åä¸€èª²", category: "åœ‹èª", words: [
            {c:"æ€ª",z:"ã„ã„¨ã„Ë‹",r:"å¿ƒéƒ¨",w:"å¥‡æ€ª"}, {c:"é–€",z:"ã„‡ã„£ËŠ",r:"é–€éƒ¨",w:"å¤§é–€"}, {c:"æ‰‡",z:"ã„•ã„¢Ë‹",r:"æˆ¶éƒ¨",w:"é›»æ‰‡"}, {c:"ç«‹",z:"ã„Œã„§Ë‹",r:"ç«‹éƒ¨",w:"èµ·ç«‹"},
            {c:"åˆ»",z:"ã„ã„œË‹",r:"åˆ€éƒ¨",w:"ç«‹åˆ»"}, {c:"é–’",z:"ã„’ã„§ã„¢ËŠ",r:"é–€éƒ¨",w:"ç©ºé–’"}, {c:"é¦¬",z:"ã„‡ã„šË‡",r:"é¦¬éƒ¨",w:"é¦¬è·¯"}, {c:"é—–",z:"ã„”ã„¨ã„¤Ë‡",r:"é–€éƒ¨",w:"é—–é—œ"},
            {c:"è€³",z:"ã„¦Ë‡",r:"è€³éƒ¨",w:"è€³æœµ"}, {c:"ä¸»",z:"ã„“ã„¨Ë‡",r:"ä¸¶éƒ¨",w:"ä¸»äºº"}, {c:"æ’­",z:"ã„…ã„›",r:"æ‰‹éƒ¨",w:"å»£æ’­"}, {c:"å ±",z:"ã„…ã„ Ë‹",r:"åœŸéƒ¨",w:"å ±å‘Š"},
            {c:"åŠ›",z:"ã„Œã„§Ë‹",r:"åŠ›éƒ¨",w:"åŠ›æ°£"}, {c:"ç«Ÿ",z:"ã„ã„§ã„¥Ë‹",r:"ç«‹éƒ¨",w:"ç«Ÿç„¶"}, {c:"å·´",z:"ã„…ã„š",r:"å·³éƒ¨",w:"å°¾å·´"}, {c:"æ±",z:"ã„‰ã„¨ã„¥",r:"æœ¨éƒ¨",w:"æ±è¥¿"},
            {c:"è¥¿",z:"ã„’ã„§",r:"è¥¾éƒ¨",w:"è¥¿ç“œ"}, {c:"åº•",z:"ã„‰ã„§Ë‡",r:"å»£éƒ¨",w:"åº•ä¸‹"}
        ]},
        "12": { title: "ç¬¬åäºŒèª²", category: "åœ‹èª", words: [
            {c:"å¿µ",z:"ã„‹ã„§ã„¢Ë‹",r:"å¿ƒéƒ¨",w:"æ€å¿µ"}, {c:"æ›²",z:"ã„‘ã„©Ë‡",r:"æ›°éƒ¨",w:"æ­Œæ›²"}, {c:"é …",z:"ã„’ã„§ã„¤Ë‹",r:"é éƒ¨",w:"é …ç›®"}, {c:"æµ®",z:"ã„ˆã„¨ËŠ",r:"æ°´éƒ¨",w:"æµ®åŠ›"},
            {c:"æŒ",z:"ã„“ã„¤Ë‡",r:"æ‰‹éƒ¨",w:"æ‰‹æŒ"}, {c:"æ’¥",z:"ã„…ã„›",r:"æ‰‹éƒ¨",w:"æ’¥é–‹"}, {c:"æ³¢",z:"ã„…ã„›",r:"æ°´éƒ¨",w:"æ³¢æµª"}, {c:"è©©",z:"ã„•",r:"è¨€éƒ¨",w:"è©©äºº"},
            {c:"ä½œ",z:"ã„—ã„¨ã„›Ë‹",r:"äººéƒ¨",w:"ä½œæ¥­"}, {c:"é¦–",z:"ã„•ã„¡Ë‡",r:"é¦–éƒ¨",w:"é¦–å…ˆ"}, {c:"æŒ‡",z:"ã„“Ë‡",r:"æ‰‹éƒ¨",w:"æ‰‹æŒ‡"}, {c:"ä¼¸",z:"ã„•ã„£",r:"äººéƒ¨",w:"ä¼¸æ‰‹"},
            {c:"è„–",z:"ã„…ã„›ËŠ",r:"è‚‰éƒ¨",w:"è„–å­"}, {c:"èº«",z:"ã„•ã„£",r:"èº«éƒ¨",w:"èº«é«”"}, {c:"é«”",z:"ã„Šã„§Ë‡",r:"éª¨éƒ¨",w:"é«”è‚²"}, {c:"éš»",z:"ã„“",r:"éš¹éƒ¨",w:"ä¸€éš»"},
            {c:"å€’",z:"ã„‰ã„ Ë‡",r:"äººéƒ¨",w:"è·Œå€’"}, {c:"è‚š",z:"ã„‰ã„¨Ë‹",r:"è‚‰éƒ¨",w:"è‚šå­"}
        ]},
        "R": { title: "å…¨ç¯„åœéš¨æ©Ÿ (10é¡Œ)", category: "åœ‹èª", mode: "random10", count: 10, words: Array(10).fill(null) },
        "M": { title: "æ•¸å­¸é¡Œ (10é¡Œ)", category: "æ•¸å­¸", mode: "math10", count: 10, words: Array(10).fill(null) },
        "T": { title: "æ™‚é˜é¡Œ (10é¡Œ)", category: "æ•¸å­¸", mode: "clock10", count: 10, words: Array(10).fill(null) },
        "A": { title: "é¢ç©æŒ‘æˆ° (10é¡Œ)", category: "æ•¸å­¸", mode: "area10", count: 10, words: Array(10).fill(null) },
        "Z": { title: "éš¨æ©Ÿç¸½è¤‡ç¿’ (10é¡Œ)", category: "ç¸½è¤‡ç¿’", mode: "mix10", count: 10, words: Array(10).fill(null) }
    };

    const GENE_EYES = [
        'ğŸ¤©', 'ğŸ˜', 'ğŸ˜', 'ğŸ¥º', 'ğŸ˜‰', 'ğŸ˜Š', 'ğŸ˜´', 'ğŸ¤—', 'ğŸ˜º', 'ğŸ˜»',
        'âœ¨', 'ğŸŒŸ', 'ğŸ’«', 'ğŸŒˆ', 'ğŸ€', 'ğŸ§¸', 'ğŸ¾', 'ğŸ¤', 'ğŸ°', 'ğŸ¹',
        'ğŸ»', 'ğŸ¼', 'ğŸ“', 'ğŸ¬', 'ğŸ§', 'ğŸ°', 'ğŸ­', 'ğŸˆ', 'ğŸ«§', 'ğŸª„'
    ];
    const GENE_MOUTHS = [
        'ğŸ˜º', 'ğŸ˜‹', 'ğŸ˜', 'ğŸ˜†', 'ğŸ˜®', 'ğŸ˜œ', 'ğŸ™‚', 'ğŸ¥³', 'ğŸ¤­', 'ğŸ˜‡',
        'ğŸ’–', 'ğŸ’—', 'ğŸ’•', 'ğŸ’', 'ğŸŒ¸', 'ğŸŒ¼', 'ğŸ¡', 'ğŸ©', 'ğŸª', 'ğŸ«',
        'ğŸ¯', 'ğŸ¦', 'ğŸ§', 'ğŸ§‹', 'ğŸ“', 'ğŸ€', 'ğŸ£', 'ğŸ±', 'ğŸ¶', 'ğŸª„'
    ];

    // --- 1. éŠæˆ²ç‹€æ…‹ç®¡ç† (ä¿®æ”¹ç‰ˆ) ---
    let gameState = {
        level: 1,
        exp: 0,
        food: 0,
        musicOn: true,
        satiety: 100,
        cleanliness: 100,
        mood: 100,
        isSick: false,
        lastLoginTime: Date.now(),
        treasureTickets: 0,
        inventory: [],
        materialInventory: [],
        synthUnlocked: [0],
        synthCurrent: 0,
        synthHasNew: false,
        backyardTickets: 0,
        unlockedCats: [0],
        currentCatIndex: 0,
        geneEyes: 'ğŸ¤©',
        geneMouth: 'ğŸ˜º',
        geneHue: 0,
        geneBlur: 0,
        geneMutations: [],
        geneCurrentId: null,
        geneActive: false,
        geneName: 'ç”œç”œå°å–µ #001',
        geneDesc: 'é–ƒé–ƒç™¼äº®ã€‚',
        geneEyeMaterials: GENE_EYES.slice(0, 3),
        geneMouthMaterials: GENE_MOUTHS.slice(0, 3)
    };

    const shopItems = [
        { id: 'item-medicine', name: 'è¬èƒ½è—¥æ°´', price: 50, icon: 'ğŸ’Š', desc: 'æ²»ç™’ç”Ÿç—…èˆ‡æ¢å¾©å¥åº·' },
        { id: 'item-treasure-ticket', name: 'è—å¯¶åˆ¸', price: 5, icon: 'ğŸŸï¸', desc: 'é–‹å•Ÿ/ä¸‹ä¸€é—œéœ€è¦', consumable: true },
        { id: 'decor-window', name: 'é¢¨æ™¯çª—æˆ¶', price: 20, icon: 'ğŸ–¼ï¸', desc: 'çœ‹çœ‹å¤–é¢çš„ä¸–ç•Œ', effectDesc: 'å¿ƒæƒ…æå‡ãƒ»è®Šæ…¢é¤“è‚šå­', effects: { moodGainPerTick: 0.4, satietyDecayMul: 0.9 } },
        { id: 'decor-rug', name: 'å½©è™¹åœ°æ¯¯', price: 15, icon: 'ğŸŒˆ', desc: 'è»Ÿç¶¿ç¶¿çš„è§¸æ„Ÿ', effectDesc: 'å¿ƒæƒ…æå‡ãƒ»æ›´å®¹æ˜“å¼„é«’', effects: { moodGainPerTick: 0.5, cleanlinessDecayMul: 1.15 } },
        { id: 'decor-toy', name: 'æ¯›ç·šçƒ', price: 10, icon: 'ğŸ§¶', desc: 'è²“å’ªæœ€æ„›ç©å…·', effectDesc: 'å¿ƒæƒ…å¤§æå‡ãƒ»é¤“å¾—æ›´å¿«', effects: { moodGainPerTick: 0.8, satietyDecayMul: 1.2 } },
        { id: 'decor-plant', name: 'ç¶ è‰²ç›†æ ½', price: 15, icon: 'ğŸŒ¿', desc: 'æ¸…æ–°å°è§’è½', effectDesc: 'è‡ªå‹•æ¸…æ½”ãƒ»è®Šæ…¢è®Šé«’', effects: { cleanlinessDecayMul: 0.7, cleanlinessGainPerTick: 0.3 } },
        { id: 'decor-lamp', name: 'ç´…ç‡ˆç± ', price: 25, icon: 'ğŸ®', desc: 'å¢æ·»æ°£æ°›', effectDesc: 'å¿ƒæƒ…æå‡ãƒ»å¤œè²“å­æ›´é¤“', effects: { moodGainPerTick: 0.4, satietyDecayMul: 1.1 } },
        { id: 'decor-balloon', name: 'æ°£çƒ', price: 10, icon: 'ğŸˆ', desc: 'é£„ä¾†é£„å»', effectDesc: 'å¿ƒæƒ…æå‡ãƒ»å¿ƒæƒ…æ›´ç©©å®š', effects: { moodGainPerTick: 0.6, moodDecayMul: 0.9 } }
    ];

    const synthMaterials = [
        { id: 'item-glass', name: 'æ”¾å¤§é¡', icon: 'ğŸ”', desc: 'åµæ¢è£å‚™', styleId: 3 },
        { id: 'item-rocket', name: 'ç©å…·ç«ç®­', icon: 'ğŸš€', desc: 'é£›å‘å®‡å®™', styleId: 4, rare: true },
        { id: 'item-guitar', name: 'é›»å‰ä»–', icon: 'ğŸ¸', desc: 'æ–æ»¾ç¯€å¥', styleId: 5 },
        { id: 'item-blood', name: 'ç•ªèŒ„æ±', icon: 'ğŸ·', desc: 'å¸è¡€é¬¼é¢¨å‘³', styleId: 6 },
        { id: 'item-cone', name: 'å†°æ·‡æ·‹', icon: 'ğŸ¦', desc: 'ç”œç­’ç•¶è§’', styleId: 7 },
        { id: 'item-shrimp', name: 'ç‚¸è¦æŠ±æ•', icon: 'ğŸ¤', desc: 'é…¥é…¥é¦™é¦™', styleId: 8 },
        { id: 'item-toilet', name: 'é¦¬æ¡¶', icon: 'ğŸš½', desc: 'æ¢éšªå®¶å°ˆç”¨', styleId: 9 },
        { id: 'item-ice', name: 'æ°¸å‡å†°å¡Š', icon: 'ğŸ§Š', desc: 'å†°éœœåŠ›é‡', styleId: 10, rare: true },
        { id: 'item-fire', name: 'é­”æ³•ç«æŠŠ', icon: 'ğŸ”¥', desc: 'ç‚ç†±èƒ½é‡', styleId: 11, rare: true }
    ];

    const synthStyles = {
        0: { name: 'åŸå‘³è²“å’ª', desc: 'ä¿ç•™åŸæœ¬çš„æ¨£å­', layers: [] },
        3: { name: 'ååµæ¢å–µå–µ', desc: 'çœŸç›¸åªæœ‰ä¸€å€‹', layers: [
            { icon: 'ğŸ§¥', size: 5.2, top: 70, z: 1 },
            { icon: 'ğŸ§', size: 3, top: 35, left: 62, z: 2 },
            { icon: 'ğŸ§¢', size: 4, top: 15, z: 2 },
            { icon: 'ğŸ”', size: 3.5, top: 60, left: 78, z: 3, rotate: -20 }
        ]},
        4: { name: 'å¤ªç©ºäººå–µå–µ', desc: 'å‘¼å«æ§åˆ¶å¡”', layers: [
            { icon: 'ğŸ”®', size: 8, opacity: 0.6, z: 2 },
            { icon: 'ğŸš€', size: 3.6, top: 20, left: 85, z: 0, anim: 'anim-float' },
            { icon: 'ğŸŒŒ', size: 9, opacity: 0.7, z: -1 }
        ]},
        5: { name: 'æ–æ»¾å·¨æ˜Ÿ', desc: 'å‘¼åš•è²æ˜¯é‡é‡‘å±¬', layers: [
            { icon: 'ğŸ•¶ï¸', size: 3.5, top: 40, z: 2 },
            { icon: 'ğŸ¸', size: 4.5, top: 75, left: 35, z: 3, rotate: 35 },
            { icon: 'âš¡', size: 3, top: 12, left: 85, anim: 'anim-shake' }
        ]},
        6: { name: 'å¸è¡€é¬¼ä¼¯çˆµ', desc: 'åªå–ç•ªèŒ„æ±', layers: [
            { icon: 'ğŸ‘¿', size: 7.5, top: 40, z: -1 },
            { icon: 'ğŸ©', size: 3.6, top: 12, z: 2 },
            { icon: 'ğŸ·', size: 3, top: 75, left: 75, z: 2 }
        ], catFilter: 'cat-filter-shadow' },
        7: { name: 'å½©è™¹ç¨è§’å–µ', desc: 'çœ‹åˆ°ç‰ ä½œæ¥­éƒ½æœƒå…¨å°', layers: [
            { icon: 'ğŸ¦', size: 3, top: 15, rotate: -15, z: 2 },
            { icon: 'ğŸŒˆ', size: 8, top: 55, opacity: 0.8, z: -1 },
            { icon: 'âœ¨', size: 3, top: 10, left: 85, anim: 'anim-spin' }
        ]},
        8: { name: 'ç‚¸è¦ç¡è¢‹å–µ', desc: 'çœ‹èµ·ä¾†å¾ˆå¥½åƒ', layers: [
            { icon: 'ğŸ¤', size: 8.5, rotate: 35, z: 2 }
        ]},
        9: { name: 'é¦¬æ¡¶æ¢éšªå®¶', desc: 'é€™æ°´å‘³é“æ€ªæ€ªçš„', layers: [
            { icon: 'ğŸš½', size: 8, z: 2 },
            { icon: 'ğŸ˜¨', size: 3, top: 30, left: 80, z: 3 }
        ]},
        10: { name: 'å†°éœœå–µ', desc: 'é è¿‘ç‰ å†·æ°£è²»éƒ½çœäº†', layers: [
            { icon: 'â„ï¸', size: 3, top: 12, left: 15, anim: 'anim-spin' },
            { icon: 'ğŸ§Š', size: 3.5, top: 80, left: 85 }
        ], catFilter: 'cat-filter-ice' },
        11: { name: 'ç‚æŸ±å–µ', desc: 'ç‰ ç¾åœ¨éå¸¸ç†±æƒ…', layers: [
            { icon: 'ğŸ”¥', size: 3.8, top: 82, z: 2 },
            { icon: 'ğŸ˜¡', size: 3, top: 40, z: 3 }
        ], catFilter: 'cat-filter-fire' }
    };

    const ROOM_ATMOSPHERE_LIST = ['â˜ï¸', 'ğŸŒ¸', 'âœ¨', 'ğŸµ', 'ğŸŒ±', 'ğŸŒ™', 'ğŸ’«'];
    const CAT_SPEECH_LIST = ['å–µå—šï½', 'å†æ‘¸ä¸€ä¸‹ï¼', 'ç½é ­åœ¨å“ªï¼Ÿ', 'ä¸€èµ·å­¸ç¿’ï¼', 'ä½ çœŸå²å®³ï¼'];
    const GENE_ADJECTIVES = ['å½©è™¹', 'æ˜Ÿæ˜Ÿ', 'æ³¡æ³¡', 'å¤¢å¹»', 'é–‹å¿ƒ', 'ç”œç”œ', 'é™½å…‰', 'é–ƒäº®'];
    const GENE_NOUNS = ['å°å–µ', 'å°ç²¾éˆ', 'å°æ³¡æ³¡', 'å°æ˜Ÿæ˜Ÿ', 'é­”æ³•è²“', 'ç”œç”œè²“', 'å½©è™¹è²“', 'å¿ƒæƒ…è²“'];
    const GENE_DESCS = [
        'ä»Šå¤©å¿ƒæƒ…å¾ˆå¥½ï¼',
        'çœ¼ç›äº®æ™¶æ™¶ã€‚',
        'å……æ»¿é­”æ³•èƒ½é‡ï½',
        'å¥½æƒ³æŠ±æŠ±å®ƒï¼',
        'æ­£åœ¨ç™¼å…‰ä¸­ã€‚'
    ];
    
    const ONLINE_DECAY_INTERVAL_MS = 30000;
    const ONLINE_SATIETY_DECAY = 2;
    const ONLINE_MOOD_DECAY = 1;
    const ONLINE_CLEAN_DECAY = 1;
    const POOP_CLEAN_PENALTY = 3;
    const CLEAN_POOP_RECOVER = 60;
    const CLEAN_POOP_MAX = 80;
    const BATH_CLEAN_COUNT = 10;
    const BACKYARD_MAX_CATS = 6;
    const BACKYARD_TICK_MS = 1000;
    const BACKYARD_MOVE_MS = 1500;
    const BACKYARD_KIBBLE_LIFE_MS = 4500;
    const BACKYARD_POOP_CHANCE = 0.05;
    const BACKYARD_POOP_SICK_MS = 15000;
    const BACKYARD_CLEAN_RECOVER = 10;
    const BACKYARD_DIAMOND_FOOD = 10;
    const BACKYARD_MEAL_GOAL = 5;
    const BACKYARD_BACKGROUNDS = [
        'icons/out-1.png',
        'icons/out-2.png',
        'icons/out-3.png',
        'icons/out-4.png'
    ];
    const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent)
        || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    const COMBO_STAGE_ONE = 3;
    const COMBO_FEVER = 5;
    const COMBO_SOUND_TIER1 = 3;
    const COMBO_SOUND_TIER2 = 4;
    const COMBO_SOUND_TIER3 = 5;
    const COMBO_SOUND_TIER4 = 7;
    const CAT_SPEECH_COOLDOWN_MS = 12000;
    const VOICE_LONG_PRESS_MS = 550;
    const TREASURE_TILE_SIZE = 36;
    const TREASURE_COLS = 11;
    const TREASURE_ROWS = 11;
    const TREASURE_TARGETS = 3;
    const TREASURE_WALL_DENSITY = 0.32;
    const TREASURE_PULL_BASE = 45;
    const NEEDS_SPEECH_THRESHOLD = 10;
    const CAT_PERSONALITIES = [
        'å‚²å¬Œã€æ„›å‘½ä»¤ä¸»äººã€å˜´ç¡¬å¿ƒè»Ÿ',
        'è²ªåƒã€æ…¢åŠæ‹ã€ç¸½æƒ³åƒç½é ­',
        'æº«æŸ”ã€æ„›æ’’å¬Œã€å–œæ­¡è¢«èª‡',
        'æ´»åŠ›æ»¿æ»¿ã€å¥½å¥‡å¿ƒçˆ†æ£šã€è©±å¾ˆå¤š',
        'å†·éœã€ç†æ€§ã€è¬›è©±ç²¾ç°¡',
        'æ„›ä¹¾æ·¨ã€æœ‰é»æ½”ç™–ã€è¨å­é«’äº‚',
        'å°å…¬ä¸»ã€æŒ‘é£Ÿã€è¬›ç©¶æ’å ´',
        'å‹‡æ•¢ã€å¥½å‹ã€æƒ³ç•¶éšŠé•·',
        'å®³ç¾ã€è¼•è²ç´°èªã€èº²åœ¨è§’è½',
        'èª¿çš®ã€æ„›æƒ¡ä½œåŠ‡ã€ç¬‘å˜»å˜»',
        'å¤¢å¹»ã€æµªæ¼«ã€æ„›æ˜Ÿæ˜Ÿ',
        'å¤é¢¨ã€å°æ›¸ç”Ÿã€èªªè©±æ–‡éœ',
        'ä¸­äºŒã€è¦ºå¾—è‡ªå·±æœ‰è¶…èƒ½åŠ›',
        'æ„›ç¡è¦ºã€æ‡¶æ´‹æ´‹ã€æ…¢åå',
        'æ„›é»äººã€éœ€è¦é™ªä¼´ã€å®¹æ˜“ä¸å®‰',
        'ç¾é£Ÿå®¶ã€å˜´åˆã€æ„›è©•è«–å£æ„Ÿ',
        'å…ƒæ°£å¶åƒã€æ„›é¼“å‹µã€å–Šå£è™Ÿ',
        'åæ§½ç³»ã€å˜´ç¢ã€æ„›å«Œæ£„',
        'å¤§å“¥é¢¨ã€è¬›ç¾©æ°£ã€è­·ä¸»å¿ƒå¼·',
        'ç¥ç§˜ã€è©±å°‘ã€å¶çˆ¾çªç„¶çˆ†æ¢—',
        'å°è€å¸«ã€æ„›ç³¾æ­£ã€é¼“å‹µå­¸ç¿’',
        'å†’éšªå®¶ã€åš®å¾€å¤–é¢ã€æƒ³å‡ºé–€',
        'éœ¸æ°£å¥³ç‹ã€æ…‹åº¦é«˜å†·ã€æ„›ä¸‹æŒ‡ä»¤',
        'æš–å¿ƒã€å¾ˆæœƒå®‰æ…°ã€æœƒç…§é¡§äºº',
        'å¹¼è²“ã€å°åƒè²¨ã€å¤©çœŸå¯æ„›'
    ];

    const EXP_PER_LEVEL = 10;
    const HAPPY_MEOW_LIST = [
        "sound/meow1.mp3",
        "sound/meow2.mp3",
        "sound/meow3.mp3",
        "sound/meow4.mp3"
    ];
    const ANGRY_MEOW_LIST = [
        "sound/an1.mp3",
        "sound/an2.mp3"
    ];
    const BGM_LIST = [
        "music/m1.mp3",
        "music/m2.mp3",
        "music/m3.mp3",
        "music/m4.mp3"
    ];
    const BOSS_BGM_LIST = [
        "music/boss-1.mp3",
        "music/boss-2.mp3",
        "music/boss-3.mp3"
    ];
    let currentBgmUrl = "";
    let bgmQueue = [];
    let currentBossBgmUrl = "";
    let bossBgmQueue = [];
    let bgmWasPlaying = false;
    let bossBgmWasPlaying = false;
    let catWalkTimer = null;
    let onlineDecayTimer = null;
    let activeDecorSlot = null;

    const catSprites = [
        "https://robohash.org/egg?set=set4&size=250x250", 
        "https://robohash.org/baby_kitten?set=set4&size=250x250", 
        "https://robohash.org/playful_cat?set=set4&size=250x250", 
        "https://robohash.org/smart_cat?set=set4&size=250x250", 
        "https://robohash.org/ninja_cat?set=set4&size=250x250", 
        "https://robohash.org/wizard_cat?set=set4&size=250x250",
        "https://robohash.org/king_cat?set=set4&size=250x250",
        "https://robohash.org/queen_cat?set=set4&size=250x250",
        "https://robohash.org/angel_cat?set=set4&size=250x250",
        "https://robohash.org/demon_cat?set=set4&size=250x250",
        "https://robohash.org/space_cat?set=set4&size=250x250",
        "https://robohash.org/robot_cat?set=set4&size=250x250",
        "https://robohash.org/ghost_cat?set=set4&size=250x250",
        "https://robohash.org/super_cat?set=set4&size=250x250",
        "https://robohash.org/mega_cat?set=set4&size=250x250",
        "https://robohash.org/ultra_cat?set=set4&size=250x250",
        "https://robohash.org/rainbow_cat?set=set4&size=250x250",
        "https://robohash.org/golden_cat?set=set4&size=250x250",
        "https://robohash.org/crystal_cat?set=set4&size=250x250",
        "https://robohash.org/shadow_cat?set=set4&size=250x250",
        "https://robohash.org/fire_cat?set=set4&size=250x250",
        "https://robohash.org/water_cat?set=set4&size=250x250",
        "https://robohash.org/earth_cat?set=set4&size=250x250",
        "https://robohash.org/wind_cat?set=set4&size=250x250",
        "https://robohash.org/god_cat?set=set4&size=250x250"
    ];

    const TREASURE_T = { FLOOR: 0, WALL: 1, BOX: 2, TARGET: 3, DONE: 4 };
    const TREASURE_DEFAULT_THEME = {
        name: "é è¨­åœ°åŸ",
        story: "è²“å’ªè¦æŠŠå¯¶ç®±æ¨é€²è—å¯¶é»ï¼",
        bgColor: "#0f172a",
        colors: {
            floor: "#1f2937",
            wall: "#475569",
            done: "rgba(34, 197, 94, 0.35)"
        },
        chars: {
            wall: "",
            player: "ğŸˆ",
            box: "ğŸ“¦",
            target: "âŒ",
            done: "ğŸ"
        }
    };

    function clampCatIndex(index) {
        if (!Number.isFinite(index)) return 0;
        return Math.max(0, Math.min(index, catSprites.length - 1));
    }

    function unlockCatSkin(index, autoEquip) {
        if (!Array.isArray(gameState.unlockedCats)) gameState.unlockedCats = [0];
        const safeIndex = clampCatIndex(index);
        if (!gameState.unlockedCats.includes(safeIndex)) {
            gameState.unlockedCats.push(safeIndex);
        }
        if (autoEquip) {
            gameState.currentCatIndex = safeIndex;
        }
    }

    // --- Boss æˆ°è®Šæ•¸ ---
    const BOSS_BASE_HP = 80;
    const BOSS_HP_PER_LEVEL = 6;
    const BOSS_MAX_HP = 200;
    const BOSS_HITS_TO_WIN = 5;
    const BOSS_HEAL_FACTOR = 6;

    let bossMaxHP = 100;
    let bossDamage = 20;
    let bossHeal = 15;
    let currentBossHP = 100;
    let bossQuestions = [];
    let bossCurrentQ = null;
    let isBossBattle = false;
    let bossPending = false;
    let pendingMaterialDrop = null;
    let pendingMajicDrop = null;
    let selectedMaterial = null;
    let catSpeechTimer = null;
    let lastCatSpeechAt = 0;
    let catSpeechInFlight = false;
    let lastNeedsSnapshot = null;
    let activeGeneTab = 'eyes';
    let bathRemaining = BATH_CLEAN_COUNT;
    let speechRecognizer = null;
    let isListening = false;
    let voiceChatMode = 'voice';
    let voiceLongPressTimer = null;
    let voiceLongPressTriggered = false;
    let voiceUnsupportedNotice = false;
    let catVoice = null;
    let treasureActive = false;
    let treasureCanvas = null;
    let treasureCtx = null;
    let treasureTheme = { ...TREASURE_DEFAULT_THEME };
    let treasureState = {
        map: [],
        player: { x: 1, y: 1 },
        goals: 0,
        done: 0,
        history: [],
        level: 0
    };
    let treasureKeybound = false;
    let treasureSpinInProgress = false;
    let treasureWheelRotation = 0;
    let treasureAudioPrimed = false;
    let backyardLoop = null;
    let backyardLastTick = 0;
    let backyardStageRect = null;
    let backyardStageWidth = 0;
    let backyardStageHeight = 0;
    let backyardCats = [];
    let backyardItems = [];
    let backyardPoops = [];
    let backyardDirtySince = null;
    let backyardSickFromPoop = false;
    let backyardSickNotified = false;
    let backyardMealProgress = 0;
    let backyardMealGoal = BACKYARD_MEAL_GOAL;
    let backyardRewarded = false;
    const particlePool = [];
    let comboCount = 0;
    let comboBonus = 0;
    let comboFever = false;
    const TREASURE_ROULETTE_VALUES = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30];
    let workSlotBaseReward = 0;
    let workSlotFinalReward = 0;
    let workSlotSpinning = false;
    let workSlotEvent = null;
    let workSlotReady = false;
    const WORK_SLOT_SYMBOL_HEIGHT = 72;
    const WORK_SLOT_OUTCOMES = [
        { id: 'miss', type: 'miss', emoji: 'ğŸª¨', label: 'æ§“é¾œ' },
        { id: 'plus1', type: 'add', value: 1, emoji: 'ğŸ', label: '+1' },
        { id: 'plus2', type: 'add', value: 2, emoji: 'ğŸŒ', label: '+2' },
        { id: 'plus3', type: 'add', value: 3, emoji: 'ğŸ“', label: '+3' },
        { id: 'plus4', type: 'add', value: 4, emoji: 'ğŸŠ', label: '+4' },
        { id: 'plus5', type: 'add', value: 5, emoji: 'ğŸ‰', label: '+5' },
        { id: 'plus6', type: 'add', value: 6, emoji: 'ğŸ‡', label: '+6' },
        { id: 'x2', type: 'mult', value: 2, emoji: 'ğŸª™', label: 'x2' },
        { id: 'x3', type: 'mult', value: 3, emoji: 'ğŸ’°', label: 'x3' },
        { id: 'x5', type: 'mult', value: 5, emoji: 'ğŸ’', label: 'x5' }
    ];
    const WORK_SLOT_SYMBOLS = WORK_SLOT_OUTCOMES.map((outcome) => outcome.emoji);
    const WORK_SLOT_STRIP_LENGTH = 18;

    function spawnParticles(x, y, emojis) {
        const count = IS_IOS ? 3 : 6;
        for (let i = 0; i < count; i += 1) {
            const el = particlePool.pop() || (() => {
                const node = document.createElement('div');
                node.className = 'emoji-particle';
                node.addEventListener('animationend', () => {
                    if (node.parentNode) node.parentNode.removeChild(node);
                    particlePool.push(node);
                });
                return node;
            })();
            el.innerText = emojis[Math.floor(Math.random() * emojis.length)];
            el.style.textShadow = IS_IOS ? 'none' : '';
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;

            const angle = Math.random() * 360;
            const distance = (IS_IOS ? 40 : 50) + Math.random() * (IS_IOS ? 60 : 90);
            const tx = Math.cos(angle * Math.PI / 180) * distance;
            const ty = Math.sin(angle * Math.PI / 180) * distance;
            const rotRange = IS_IOS ? 360 : 720;
            const rot = Math.floor(Math.random() * rotRange - rotRange / 2);

            el.style.setProperty('--tx', `${tx}px`);
            el.style.setProperty('--ty', `${ty}px`);
            el.style.setProperty('--rot', `${rot}deg`);

            el.style.animation = 'none';
            void el.offsetHeight;
            el.style.animation = '';
            document.body.appendChild(el);
        }
    }

    function applyNeedsDecay(satietyLoss, cleanlinessLoss, moodLoss) {
        if (!satietyLoss && !cleanlinessLoss && !moodLoss) return;
        const effects = getActiveDecorEffects();
        const satietyAdjusted = satietyLoss * effects.satietyDecayMul;
        const cleanAdjusted = cleanlinessLoss * effects.cleanlinessDecayMul;
        const moodAdjusted = moodLoss * effects.moodDecayMul;

        gameState.satiety = Math.min(100, Math.max(0, gameState.satiety - satietyAdjusted + effects.satietyGainPerTick));
        gameState.cleanliness = Math.min(100, Math.max(0, gameState.cleanliness - cleanAdjusted + effects.cleanlinessGainPerTick));
        gameState.mood = Math.min(100, Math.max(0, gameState.mood - moodAdjusted + effects.moodGainPerTick));

        if (gameState.satiety < 10 || gameState.cleanliness < 20) {
            gameState.isSick = true;
        }
        checkNeedsSpeech('decay');
        gameState.lastLoginTime = Date.now();
        saveGame();
    }

    function startOnlineDecay() {
        if (onlineDecayTimer) return;
        onlineDecayTimer = setInterval(() => {
            applyNeedsDecay(ONLINE_SATIETY_DECAY, ONLINE_CLEAN_DECAY, ONLINE_MOOD_DECAY);
        }, ONLINE_DECAY_INTERVAL_MS);
    }

    function stopOnlineDecay() {
        if (!onlineDecayTimer) return;
        clearInterval(onlineDecayTimer);
        onlineDecayTimer = null;
    }

    // --- æ–°å¢ï¼šé›¢ç·šæ™‚é–“è¨ˆç®—èˆ‡ç‹€æ…‹æ›´æ–° ---
    function calculateOfflineProgress() {
        const now = Date.now();
        const lastTime = gameState.lastLoginTime || now;
        const hoursPassed = (now - lastTime) / (1000 * 60 * 60);

        if (hoursPassed > 0.1) {
            const decay = Math.floor(hoursPassed * 3);
            const effects = getActiveDecorEffects();

            gameState.satiety = Math.max(0, gameState.satiety - (decay * 2 * effects.satietyDecayMul));
            gameState.cleanliness = Math.max(0, gameState.cleanliness - (decay * effects.cleanlinessDecayMul));
            gameState.mood = Math.max(0, gameState.mood - (decay * effects.moodDecayMul));

            const newPoops = Math.min(5, Math.floor(hoursPassed / 2));
            if (newPoops > 0) {
                gameState.cleanliness = Math.max(0, gameState.cleanliness - (newPoops * POOP_CLEAN_PENALTY * effects.cleanlinessDecayMul));
            }

            if (gameState.satiety < 10 || gameState.cleanliness < 20) {
                gameState.isSick = true;
            }

            setTimeout(() => {
                if (gameState.isSick) {
                    alert(`ä½ å›ä¾†äº†ï¼ä½†æ˜¯è²“å’ªç”Ÿç—…äº†... ğŸ˜·\né›¢é–‹äº† ${hoursPassed.toFixed(1)} å°æ™‚ã€‚\nè«‹è²·è—¥æ°´æˆ–ç…§é¡§å®ƒï¼`);
                } else if (newPoops > 0) {
                    alert(`ä½ å›ä¾†äº†ï¼æˆ¿é–“æœ‰é»é«’äº‚... ğŸ’©\nè¨˜å¾—æ¸…ç†ä¸€ä¸‹å–”ï¼`);
                }
            }, 1000);
        }
        gameState.lastLoginTime = now;
        saveGame();
    }

    function loadGame() {
        const saved = localStorage.getItem('catGameSave');
        if (saved) {
            try {
                const parsed = JSON.parse(saved);
                gameState = { ...gameState, ...parsed };
            } catch(e) {}
        }
        if (!Array.isArray(gameState.inventory)) gameState.inventory = [];
        if (!Array.isArray(gameState.decorSlots)) gameState.decorSlots = Array(4).fill(null);
        if (gameState.decorSlots.length < 4) {
            gameState.decorSlots = [...gameState.decorSlots, ...Array(4 - gameState.decorSlots.length).fill(null)];
        }
        if (!Array.isArray(gameState.materialInventory)) gameState.materialInventory = [];
        if (!Array.isArray(gameState.synthUnlocked)) gameState.synthUnlocked = [0];
        if (typeof gameState.synthCurrent !== 'number') gameState.synthCurrent = 0;
        if (typeof gameState.synthHasNew !== 'boolean') gameState.synthHasNew = false;
        if (!Array.isArray(gameState.unlockedCats)) gameState.unlockedCats = [0];
        if (typeof gameState.currentCatIndex !== 'number') gameState.currentCatIndex = 0;
        if (!Array.isArray(gameState.geneMutations)) gameState.geneMutations = [];
        if (!Array.isArray(gameState.geneEyeMaterials)) gameState.geneEyeMaterials = GENE_EYES.slice(0, 3);
        if (!Array.isArray(gameState.geneMouthMaterials)) gameState.geneMouthMaterials = GENE_MOUTHS.slice(0, 3);
        if (typeof gameState.geneEyes !== 'string') gameState.geneEyes = GENE_EYES[0];
        if (typeof gameState.geneMouth !== 'string') gameState.geneMouth = GENE_MOUTHS[0];
        if (typeof gameState.geneHue !== 'number') gameState.geneHue = 0;
        if (typeof gameState.geneBlur !== 'number') gameState.geneBlur = 0;
        if (typeof gameState.geneActive !== 'boolean') gameState.geneActive = false;
        if (typeof gameState.geneName !== 'string') gameState.geneName = 'ç”œç”œå°å–µ #001';
        if (typeof gameState.geneDesc !== 'string') gameState.geneDesc = 'é–ƒé–ƒç™¼äº®ã€‚';
        if (gameState.geneCurrentId === undefined) gameState.geneCurrentId = null;
        if (!gameState.geneEyeMaterials.includes(gameState.geneEyes)) {
            gameState.geneEyeMaterials.push(gameState.geneEyes);
        }
        if (!gameState.geneMouthMaterials.includes(gameState.geneMouth)) {
            gameState.geneMouthMaterials.push(gameState.geneMouth);
        }
        if (!synthStyles[gameState.synthCurrent]) gameState.synthCurrent = 0;
        if (!gameState.synthUnlocked.includes(gameState.synthCurrent)) {
            gameState.synthUnlocked.push(gameState.synthCurrent);
        }
        if (gameState.musicOn === undefined) gameState.musicOn = true;
        if (typeof gameState.satiety !== 'number') gameState.satiety = 100;
        if (typeof gameState.cleanliness !== 'number') gameState.cleanliness = 100;
        if (typeof gameState.mood !== 'number') gameState.mood = 100;
        if (typeof gameState.isSick !== 'boolean') gameState.isSick = false;
        if (typeof gameState.treasureTickets !== 'number') gameState.treasureTickets = 0;
        if (typeof gameState.backyardTickets !== 'number') gameState.backyardTickets = 0;
        if (typeof gameState.lastLoginTime !== 'number') gameState.lastLoginTime = Date.now();

        calculateOfflineProgress();

        gameState.level = Math.max(1, Math.floor(gameState.exp / EXP_PER_LEVEL) + 1);
        const levelIndex = clampCatIndex(gameState.level - 1);
        for (let i = 0; i <= levelIndex; i += 1) {
            if (!gameState.unlockedCats.includes(i)) gameState.unlockedCats.push(i);
        }
        if (!gameState.unlockedCats.includes(gameState.currentCatIndex)) {
            gameState.currentCatIndex = levelIndex;
        }
        gameState.currentCatIndex = clampCatIndex(gameState.currentCatIndex);
        updateRoomUI();
        renderSynthStyle(gameState.synthCurrent);
        applyGeneState();
        updateNeedsSnapshot();
    }

    function pickRandomBgmUrl() {
        if (!BGM_LIST.length) return "";
        const idx = Math.floor(Math.random() * BGM_LIST.length);
        return BGM_LIST[idx];
    }

    function resetComboState() {
        comboCount = 0;
        comboBonus = 0;
        comboFever = false;
        updateComboUI();
        setFeverMode(false);
    }

    function updateComboUI() {
        const label = document.getElementById('combo-label');
        const stage = document.getElementById('combo-stage');
        const fill = document.getElementById('combo-fill');
        if (label) label.innerText = `COMBO x${comboCount}`;
        if (stage) {
            if (comboCount >= COMBO_FEVER) stage.innerText = 'FEVER';
            else if (comboCount >= COMBO_STAGE_ONE) stage.innerText = `${comboCount - COMBO_STAGE_ONE}/${COMBO_FEVER - COMBO_STAGE_ONE}`;
            else stage.innerText = `${comboCount}/${COMBO_STAGE_ONE}`;
        }
        if (fill) {
            let pct = 0;
            if (comboCount >= COMBO_FEVER) pct = 100;
            else if (comboCount >= COMBO_STAGE_ONE) {
                pct = ((comboCount - COMBO_STAGE_ONE) / (COMBO_FEVER - COMBO_STAGE_ONE)) * 100;
            } else {
                pct = (comboCount / COMBO_STAGE_ONE) * 100;
            }
            fill.style.width = `${Math.min(100, Math.max(0, pct))}%`;
        }
        updateComboEffects();
    }

    function setFeverMode(active) {
        return;
    }

    function updateComboEffects() {
        return;
    }

    function playComboSfx(level) {
        if (level === COMBO_SOUND_TIER4) {
            playSound('sfx-combo-4');
        } else if (level === COMBO_SOUND_TIER3) {
            playSound('sfx-combo-3');
        } else if (level === COMBO_SOUND_TIER2) {
            playSound('sfx-combo-2');
        } else if (level === COMBO_SOUND_TIER1) {
            playSound('sfx-combo-1');
        }
    }

    function triggerComboCheer(level) {
        if (level >= COMBO_SOUND_TIER4) {
            spawnParticles(window.innerWidth / 2, window.innerHeight * 0.25, ['ğŸ”¥', 'ğŸ’¥', 'âœ¨']);
        } else if (level >= COMBO_FEVER) {
            spawnParticles(window.innerWidth / 2, window.innerHeight * 0.25, ['ğŸ”¥', 'âœ¨', 'ğŸ’«']);
        } else if (level >= COMBO_STAGE_ONE) {
            spawnParticles(window.innerWidth / 2, window.innerHeight * 0.25, ['âœ¨', 'ğŸ’–', 'â­']);
        }
        const speech = document.getElementById('study-speech');
        if (speech) {
            const rect = speech.getBoundingClientRect();
            spawnParticles(rect.left + rect.width / 2, rect.top, ['âœ¨', 'ğŸ’–', 'â­']);
        }
    }

    function handleComboCorrect() {
        comboCount += 1;
        if (comboCount >= COMBO_FEVER) {
            comboBonus += 1;
            if (!comboFever) {
                comboFever = true;
                setFeverMode(true);
            }
        } else if (comboCount >= COMBO_STAGE_ONE) {
            comboBonus += 0.2;
        }
        updateComboUI();
        playComboSfx(comboCount);
        triggerComboCheer(comboCount);
    }

    function handleComboWrong() {
        comboCount = 0;
        comboFever = false;
        updateComboUI();
        setFeverMode(false);
        updateComboEffects();
    }

    function preloadImages(urls) {
        if (!Array.isArray(urls) || !urls.length) return;
        let idx = 0;
        const loadNext = () => {
            if (idx >= urls.length) return;
            const img = new Image();
            img.decoding = 'async';
            img.onload = img.onerror = () => {
                idx += 1;
                scheduleNext();
            };
            img.src = urls[idx];
        };
        const scheduleNext = () => {
            if ('requestIdleCallback' in window) {
                requestIdleCallback(loadNext, { timeout: 200 });
            } else {
                setTimeout(loadNext, 80);
            }
        };
        scheduleNext();
    }

    function pickRandom(list) {
        if (!list.length) return "";
        const idx = Math.floor(Math.random() * list.length);
        return list[idx];
    }

    function shuffle(list) {
        const copy = [...list];
        for (let i = copy.length - 1; i > 0; i -= 1) {
            const j = Math.floor(Math.random() * (i + 1));
            [copy[i], copy[j]] = [copy[j], copy[i]];
        }
        return copy;
    }

    function getAllWords() {
        return Object.values(lessons)
            .filter((lesson) => !lesson.mode)
            .flatMap((lesson) => lesson.words);
    }

    function buildRandomWords(count) {
        const pool = shuffle(getAllWords());
        return pool.slice(0, count).map((word) => ({ ...word }));
    }

    function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function buildStoryQuestions(count) {
        const templates = shuffle([
            () => {
                const price = randInt(6, 15);
                const qty = randInt(2, 9);
                return {
                    story: `åª½åª½è²·èœï¼Œæ¯é¡†è˜‹æœ ${price} å…ƒï¼Œè²·äº† ${qty} é¡†ï¼Œä¸€å…±å¤šå°‘å…ƒï¼Ÿ`,
                    answer: String(price * qty)
                };
            },
            () => {
                const kids = randInt(2, 8);
                const per = randInt(2, Math.min(8, Math.floor(50 / kids)));
                const candies = kids * per;
                return {
                    story: `æœ‰ ${candies} é¡†ç³–æœï¼Œå¹³å‡åˆ†çµ¦ ${kids} å€‹å°æœ‹å‹ï¼Œæ¯äººå¹¾é¡†ï¼Ÿ`,
                    answer: String(per)
                };
            },
            () => {
                const total = randInt(20, 50);
                const used = randInt(6, total - 6);
                return {
                    story: `å°æ˜æœ‰ ${total} å…ƒï¼Œè²·æ–‡å…·èŠ±äº† ${used} å…ƒï¼Œé‚„å‰©å¤šå°‘å…ƒï¼Ÿ`,
                    answer: String(total - used)
                };
            },
            () => {
                const a = randInt(6, 25);
                const b = randInt(6, 25);
                return {
                    story: `ç±ƒå­è£¡æœ‰ ${a} é¡†æ©˜å­ï¼Œåˆæ”¾é€² ${b} é¡†ï¼Œä¸€å…±æœ‰å¹¾é¡†ï¼Ÿ`,
                    answer: String(a + b)
                };
            },
            () => {
                const per = randInt(2, 9);
                const days = randInt(2, 7);
                return {
                    story: `æ¯å¤©è®€ ${per} é ï¼Œé€£çºŒè®€ ${days} å¤©ï¼Œä¸€å…±è®€äº†å¹¾é ï¼Ÿ`,
                    answer: String(per * days)
                };
            }
        ]);
        const questions = [];
        for (let i = 0; i < count; i += 1) {
            const pick = templates[i % templates.length]();
            questions.push({
                type: "story",
                q: "æƒ…å¢ƒé¡Œ",
                a: pick.answer,
                r: "æ•¸å­¸é¡Œ",
                w: pick.story
            });
        }
        return questions;
    }

    function buildBasicMathQuestion() {
        const useMultiply = Math.random() < 0.5;
        if (useMultiply) {
            const a = randInt(2, 9);
            const b = randInt(2, 9);
            return {
                type: "math",
                q: `${a} Ã— ${b}`,
                a: String(a * b),
                r: "æ•¸å­¸é¡Œ",
                w: `${a} Ã— ${b} = ${a * b}`
            };
        }
        const a = randInt(6, 44);
        const b = randInt(6, 50 - a);
        return {
            type: "math",
            q: `${a} + ${b}`,
            a: String(a + b),
            r: "æ•¸å­¸é¡Œ",
            w: `${a} + ${b} = ${a + b}`
        };
    }

    function buildMultiQuestion() {
        const themes = [
            { emoji: "ğŸš²", name: "è¼ªå­", mult: 2, unit: "å€‹" },
            { emoji: "ğŸŒ", name: "é¦™è•‰", mult: 5, unit: "æ ¹" },
            { emoji: "ğŸ™", name: "ç« é­šè…³", mult: 8, unit: "éš»" },
            { emoji: "ğŸš—", name: "è¼ªå­", mult: 4, unit: "å€‹" },
            { emoji: "ğŸ«", name: "å·§å…‹åŠ›", mult: 6, unit: "å¡Š" },
            { emoji: "ğŸ¡", name: "ä¸¸å­", mult: 3, unit: "é¡†" }
        ];
        const theme = pickRandom(themes);
        const groups = randInt(2, 9);
        const answer = groups * theme.mult;
        return {
            type: "math",
            q: `${theme.mult} Ã— ${groups}`,
            a: String(answer),
            r: "æ•¸å­¸é¡Œ",
            h: `æœ‰ ${groups} çµ„ ${theme.emoji}ï¼Œæ¯çµ„ ${theme.mult}${theme.unit}ã€‚å…±æœ‰å¤šå°‘${theme.unit}ï¼Ÿ`,
            w: `${theme.mult} Ã— ${groups} = ${answer}`
        };
    }

    function buildTimeQuestion() {
        const h = randInt(1, 12);
        const m = randInt(0, 11) * 5;
        const minuteText = m === 0 ? "æ•´é»" : `${m}åˆ†`;
        return {
            type: "math",
            q: "çœ‹æ™‚é˜å›ç­”",
            a: `${h}é»${m}åˆ†`,
            r: "æ•¸å­¸é¡Œ",
            h: "",
            w: `æ™‚é–“æ˜¯ ${h}é»${m}åˆ†`,
            visual: "clock",
            time: { h, m }
        };
    }

    function buildClockQuestions(count) {
        const questions = [];
        for (let i = 0; i < count; i += 1) {
            questions.push(buildTimeQuestion());
        }
        return shuffle(questions);
    }

    function buildStep2Question() {
        const useBus = Math.random() < 0.5;
        if (useBus) {
            const start = randInt(10, 24);
            const down = randInt(1, 6);
            const up = randInt(2, 8);
            const answer = start - down + up;
            return {
                type: "math",
                q: "å…©æ­¥é©Ÿé¡Œ",
                a: String(answer),
                r: "æ•¸å­¸é¡Œ",
                h: `å…¬è»Šä¸ŠåŸæœ¬æœ‰ ${start} äººï¼Œä¸‹è»Š ${down} äººï¼Œå¾Œä¾†åˆä¸Šè»Š ${up} äººã€‚ç¾åœ¨æœ‰å¹¾äººï¼Ÿ`,
                w: `${start} - ${down} + ${up} = ${answer}`
            };
        }
        const base = randInt(10, 20);
        const add1 = randInt(2, 6);
        const add2 = randInt(2, 6);
        const answer = base + add1 + add2;
        return {
            type: "math",
            q: "å…©æ­¥é©Ÿé¡Œ",
            a: String(answer),
            r: "æ•¸å­¸é¡Œ",
            h: `ç´«çƒæœ‰ ${base} é¡†ï¼Œç´…çƒæ¯”ç´«çƒå¤š ${add1} é¡†ï¼Œç¶ çƒæ¯”ç´…çƒå¤š ${add2} é¡†ã€‚ç¶ çƒæœ‰å¹¾é¡†ï¼Ÿ`,
            w: `${base} + ${add1} + ${add2} = ${answer}`
        };
    }

    function buildMathQuestions(count) {
        const storyCount = Math.min(3, Math.floor(count / 3));
        const questions = buildStoryQuestions(storyCount);
        const generators = [
            buildBasicMathQuestion,
            buildBasicMathQuestion,
            buildMultiQuestion,
            buildTimeQuestion,
            buildStep2Question
        ];
        for (let i = storyCount; i < count; i += 1) {
            const pick = pickRandom(generators);
            questions.push(pick());
        }
        return shuffle(questions);
    }

    function buildAreaQuestions(count) {
        const questions = [];
        const variants = ['count', 'diff', 'sum'];
        const makeGrid = () => {
            const cols = randInt(2, 6);
            const rows = randInt(2, 6);
            return { cols, rows, total: cols * rows };
        };
        for (let i = 0; i < count; i += 1) {
            const variant = pickRandom(variants);
            const grid1 = makeGrid();

            if (variant === 'count') {
                questions.push({
                    type: "area",
                    q: "é¢ç©é¡Œ",
                    a: String(grid1.total),
                    r: "æ•¸å­¸é¡Œ",
                    w: "æ•¸æ•¸çœ‹æœ‰å¹¾æ ¼ï¼Ÿ",
                    grid: { cols: grid1.cols, rows: grid1.rows }
                });
                continue;
            }

            let grid2 = makeGrid();
            if (variant === 'equal' && Math.random() < 0.5) {
                grid2 = { cols: grid1.cols, rows: grid1.rows, total: grid1.total };
            }

            let answer = '';
            let prompt = '';
            let left = grid1;
            let right = grid2;

            if (variant === 'diff') {
                if (left.total < right.total) {
                    [left, right] = [right, left];
                }
                answer = String(left.total - right.total);
                prompt = 'å·¦é‚Šæ¯”å³é‚Šå¤šå¹¾æ ¼ï¼Ÿ';
            } else if (variant === 'sum') {
                answer = String(left.total + right.total);
                prompt = 'å·¦å³åˆèµ·ä¾†ç¸½å…±å¹¾æ ¼ï¼Ÿ';
            }

            questions.push({
                type: "area",
                q: "é¢ç©é¡Œ",
                a: answer,
                r: "æ•¸å­¸é¡Œ",
                w: prompt,
                grid: { cols: left.cols, rows: left.rows },
                grid2: { cols: right.cols, rows: right.rows }
            });
        }
        return shuffle(questions);
    }

    function buildMixedQuestions(count) {
        const result = [];
        const wordPool = shuffle(getAllWords());
        const mathPool = buildMathQuestions(Math.ceil(count * 0.2));
        const areaPool = buildAreaQuestions(Math.ceil(count * 0.2));
        const totalWords = Math.max(0, count - mathPool.length - areaPool.length);
        const wordItems = wordPool.slice(0, totalWords).map((word) => ({ ...word }));
        const mix = shuffle([...wordItems, ...mathPool, ...areaPool]);
        return mix.slice(0, count);
    }

    function nextBgmUrl() {
        if (!BGM_LIST.length) return "";
        if (bgmQueue.length === 0) {
            bgmQueue = shuffle(BGM_LIST);
            if (bgmQueue.length > 1 && bgmQueue[0] === currentBgmUrl) {
                bgmQueue.push(bgmQueue.shift());
            }
        }
        return bgmQueue.shift();
    }

    function nextBossBgmUrl() {
        if (!BOSS_BGM_LIST.length) return "";
        if (bossBgmQueue.length === 0) {
            bossBgmQueue = shuffle(BOSS_BGM_LIST);
            if (bossBgmQueue.length > 1 && bossBgmQueue[0] === currentBossBgmUrl) {
                bossBgmQueue.push(bossBgmQueue.shift());
            }
        }
        return bossBgmQueue.shift();
    }

    function normalizeAudioSrc(path) {
        if (!path) return "";
        return path.startsWith("http") ? path : encodeURI(path);
    }

    function setRandomBgm(shouldPlay) {
        const bgm = document.getElementById('bgm');
        if (!bgm) return;
        let nextUrl = normalizeAudioSrc(nextBgmUrl());
        if (!nextUrl) return;
        if (bgm.src !== nextUrl) {
            bgm.src = nextUrl;
        }
        currentBgmUrl = nextUrl;
        bgm.load();
        if (shouldPlay && gameState.musicOn) {
            bgm.volume = 0.2;
            bgm.play().catch(() => {});
        }
    }

    function setRandomBossBgm() {
        const bossBgm = document.getElementById('sfx-boss-bgm');
        if (!bossBgm) return;
        const nextUrl = normalizeAudioSrc(nextBossBgmUrl());
        if (!nextUrl) return;
        if (bossBgm.src !== nextUrl) {
            bossBgm.src = nextUrl;
        }
        currentBossBgmUrl = nextUrl;
        bossBgm.load();
    }

    function saveGame() {
        localStorage.setItem('catGameSave', JSON.stringify(gameState));
        updateRoomUI();
    }

    function updateRoomUI() {
        // å®‰å…¨æª¢æŸ¥ï¼Œé˜²æ­¢å…ƒç´ ä¸å­˜åœ¨å ±éŒ¯
        const uiLevel = document.getElementById('ui-level');
        const uiFood = document.getElementById('ui-food');
        const uiExpText = document.getElementById('ui-exp-text');
        const uiExpBar = document.getElementById('ui-exp-bar');
        const catImg = document.getElementById('cat-image');

        if (uiLevel) uiLevel.innerText = gameState.level;
        if (uiFood) uiFood.innerText = gameState.food;

        const currentExp = gameState.exp % EXP_PER_LEVEL;
        const pct = (currentExp / EXP_PER_LEVEL) * 100;

        if (uiExpText) uiExpText.innerText = `${currentExp}/${EXP_PER_LEVEL}`;
        if (uiExpBar) uiExpBar.style.width = `${pct}%`;

        const satBar = document.getElementById('ui-satiety-bar');
        const moodBar = document.getElementById('ui-mood-bar');
        const cleanBar = document.getElementById('ui-clean-bar');
        const satText = document.getElementById('ui-satiety-text');
        const moodText = document.getElementById('ui-mood-text');
        const cleanText = document.getElementById('ui-clean-text');
        
        if (satBar) satBar.style.width = `${gameState.satiety}%`;
        if (moodBar) moodBar.style.width = `${gameState.mood}%`;
        if (cleanBar) cleanBar.style.width = `${gameState.cleanliness}%`;
        if (satText) satText.innerText = `${Math.round(gameState.satiety)}%`;
        if (moodText) moodText.innerText = `${Math.round(gameState.mood)}%`;
        if (cleanText) cleanText.innerText = `${Math.round(gameState.cleanliness)}%`;

        const sickIcon = document.getElementById('status-sick');
        if (sickIcon) sickIcon.classList.toggle('hidden', !gameState.isSick);
        const hungryIcon = document.getElementById('status-hungry');
        if (hungryIcon) hungryIcon.classList.toggle('hidden', gameState.satiety > 30);

        if (catImg) {
            if (gameState.isSick) {
                catImg.style.filter = 'grayscale(100%) brightness(80%) sepia(30%)';
            } else {
                catImg.style.filter = '';
                const style = getSynthStyle(gameState.synthCurrent);
                setCatFilter(style.catFilter);
            }
        }

        const levelIndex = clampCatIndex(gameState.level - 1);
        if (!gameState.unlockedCats.includes(levelIndex)) {
            unlockCatSkin(levelIndex, false);
        }
        const currentIndex = clampCatIndex(
            typeof gameState.currentCatIndex === 'number' ? gameState.currentCatIndex : levelIndex
        );
        if (catImg) catImg.src = catSprites[currentIndex];
        const studyAvatar = document.getElementById('study-cat-avatar');
        if (studyAvatar) studyAvatar.src = catSprites[currentIndex];

        renderDecorSlots();

        const shopFood = document.getElementById('shop-food-display');
        if (shopFood) shopFood.innerText = gameState.food;

        const synthBadge = document.getElementById('synth-badge');
        if (synthBadge) {
            if (gameState.synthHasNew) synthBadge.classList.remove('hidden');
            else synthBadge.classList.add('hidden');
        }

        updateTreasureTicketUI();

        renderSynthStyle(gameState.synthCurrent);
        applyGeneState();
    }

    function getDecorItemById(itemId) {
        return shopItems.find((item) => item.id === itemId);
    }

    function getActiveDecorEffects() {
        const effects = {
            satietyDecayMul: 1,
            cleanlinessDecayMul: 1,
            moodDecayMul: 1,
            satietyGainPerTick: 0,
            cleanlinessGainPerTick: 0,
            moodGainPerTick: 0
        };
        const slots = gameState.decorSlots || [];
        slots.forEach((itemId) => {
            const item = getDecorItemById(itemId);
            if (!item || !item.effects) return;
            const effect = item.effects;
            if (effect.satietyDecayMul) effects.satietyDecayMul *= effect.satietyDecayMul;
            if (effect.cleanlinessDecayMul) effects.cleanlinessDecayMul *= effect.cleanlinessDecayMul;
            if (effect.moodDecayMul) effects.moodDecayMul *= effect.moodDecayMul;
            if (effect.satietyGainPerTick) effects.satietyGainPerTick += effect.satietyGainPerTick;
            if (effect.cleanlinessGainPerTick) effects.cleanlinessGainPerTick += effect.cleanlinessGainPerTick;
            if (effect.moodGainPerTick) effects.moodGainPerTick += effect.moodGainPerTick;
        });
        return effects;
    }

    function renderDecorShelf() {
        const shelf = document.getElementById('decor-shelf');
        if (!shelf) return;
        shelf.innerHTML = '';
        if (!gameState.inventory.length) {
            const empty = document.createElement('div');
            empty.className = 'text-[11px] text-gray-400';
            empty.innerText = 'å…ˆå»å•†åº—è²·è£é£¾å§ï½';
            shelf.appendChild(empty);
            return;
        }

        gameState.inventory.forEach((itemId) => {
            const item = getDecorItemById(itemId);
            if (!item) return;
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = `decor-shelf-item${selectedDecorId === itemId ? ' selected' : ''}`;
            btn.innerText = item.icon;
            btn.draggable = true;
            btn.addEventListener('dragstart', (e) => {
                e.dataTransfer?.setData('text/plain', itemId);
                selectedDecorId = itemId;
                renderDecorShelf();
            });
            btn.addEventListener('click', () => {
                selectedDecorId = itemId;
                renderDecorShelf();
            });
            shelf.appendChild(btn);
        });
    }

    function renderDecorSlots() {
        const slots = document.querySelectorAll('.decor-slot');
        slots.forEach((slot) => {
            const index = Number(slot.dataset.slot || 0);
            const itemId = gameState.decorSlots[index];
            const item = getDecorItemById(itemId);
            slot.classList.toggle('filled', Boolean(item));
            slot.innerText = item ? item.icon : '+';
            slot.title = item ? `è£é£¾ï¼š${item.name}` : 'æ‹–æ›³è£é£¾åˆ°é€™è£¡';
        });
    }

    function openDecorPicker(slotIndex) {
        const picker = document.getElementById('decor-picker');
        const list = document.getElementById('decor-picker-list');
        if (!picker || !list) return;
        playClickSfx();
        activeDecorSlot = slotIndex;
        list.innerHTML = '';

        if (!gameState.inventory.length) {
            const empty = document.createElement('div');
            empty.className = 'col-span-4 text-xs text-gray-400 text-center py-2';
            empty.innerText = 'å…ˆå»å•†åº—è²·è£é£¾å§ï½';
            list.appendChild(empty);
        } else {
            gameState.inventory.forEach((itemId) => {
                const item = getDecorItemById(itemId);
                if (!item) return;
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'decor-picker-item';
                btn.innerText = item.icon;
                btn.title = item.name;
                btn.addEventListener('click', () => {
                    placeDecorAt(slotIndex, itemId);
                    closeDecorPicker();
                });
                list.appendChild(btn);
            });
        }

        const clearBtn = document.createElement('button');
        clearBtn.type = 'button';
        clearBtn.className = 'decor-picker-item';
        clearBtn.innerText = 'âœ–ï¸';
        clearBtn.title = 'ç§»é™¤è£é£¾';
        clearBtn.addEventListener('click', () => {
            removeDecorAt(slotIndex);
            closeDecorPicker();
        });
        list.appendChild(clearBtn);

        picker.classList.remove('hidden');
    }

    function closeDecorPicker() {
        const picker = document.getElementById('decor-picker');
        if (picker) picker.classList.add('hidden');
        activeDecorSlot = null;
        playClickSfx();
    }

    function placeDecorAt(slotIndex, itemId) {
        if (!itemId || !gameState.inventory.includes(itemId)) return;
        gameState.decorSlots = gameState.decorSlots.map((value, idx) => (value === itemId && idx !== slotIndex ? null : value));
        gameState.decorSlots[slotIndex] = itemId;
        saveGame();
        renderDecorSlots();
        const item = getDecorItemById(itemId);
        requestCatSpeech('decor-change', { itemName: item ? item.name : '' });
    }

    function removeDecorAt(slotIndex) {
        if (!gameState.decorSlots[slotIndex]) return;
        const item = getDecorItemById(gameState.decorSlots[slotIndex]);
        gameState.decorSlots[slotIndex] = null;
        saveGame();
        renderDecorSlots();
        requestCatSpeech('decor-change', { itemName: item ? `${item.name}å·²ç§»é™¤` : 'ç§»é™¤è£é£¾' });
    }

    // --- éŸ³æ•ˆæ’­æ”¾ (å«å®‰å…¨æ©Ÿåˆ¶) ---
    function playSound(id) {
        try {
            const audio = document.getElementById(id);
            if (audio) {
                audio.muted = false;
                audio.currentTime = 0;
                audio.volume = 0.5;
                const promise = audio.play();
                if (promise !== undefined) {
                    promise.catch(error => {
                        console.log("Sound play error (safe):", id);
                    });
                }
            }
        } catch(e) {
            console.log("Audio Element missing or error");
        }
    }

    function playSoundFor(id, durationMs) {
        try {
            const audio = document.getElementById(id);
            if (!audio) return;
            audio.muted = false;
            audio.currentTime = 0;
            audio.volume = 0.5;
            const promise = audio.play();
            if (promise !== undefined) {
                promise.catch(() => {});
            }
            setTimeout(() => {
                audio.pause();
                audio.currentTime = 0;
            }, durationMs);
        } catch(e) {}
    }

    function playClickSfx() {
        playSound('sfx-don');
    }

    function startCatWalk() {
        stopCatWalk();
        startOnlineDecay();
        const step = () => {
            walkCat();
            const delay = randInt(5000, 9000);
            catWalkTimer = setTimeout(step, delay);
        };
        catWalkTimer = setTimeout(step, 3000);
    }

    function stopCatWalk() {
        if (catWalkTimer) {
            clearTimeout(catWalkTimer);
            catWalkTimer = null;
        }
    }

    function walkCat() {
        const cat = document.getElementById('cat-container');
        const catBody = document.getElementById('cat-body');
        const zone = document.getElementById('cat-zone');
        if (!cat || !zone) return;
        const zoneWidth = zone.clientWidth || 0;
        const catWidth = cat.clientWidth || 0;
        const baseShift = Math.max(0, Math.floor((zoneWidth - catWidth) / 2));
        const minShift = Math.min(60, Math.floor(zoneWidth * 0.2));
        const maxShift = Math.max(baseShift, minShift);
        const offset = randInt(-maxShift, maxShift);
        cat.style.setProperty('--cat-x', `${offset}px`);
        if (catBody) {
            if (offset < -6) {
                catBody.classList.add('facing-left');
            } else if (offset > 6) {
                catBody.classList.remove('facing-left');
            }
        }
        if (Math.random() < 0.25) {
            spawnPoop();
        }
    }

    function spawnPoop() {
        const layer = document.getElementById('poop-layer');
        const cat = document.getElementById('cat-container');
        const room = document.getElementById('scene-room');
        if (!layer || !cat || !room) return;
        if (room.classList.contains('hidden')) return;
        if (layer.children.length >= 6) return;
        const rect = cat.getBoundingClientRect();
        const roomRect = room.getBoundingClientRect();
        const x = rect.left - roomRect.left + rect.width * 0.5 + randInt(-24, 24);
        const y = rect.bottom - roomRect.top - 18 + randInt(-6, 10);
        const maxX = roomRect.width - 24;
        const maxY = roomRect.height - 24;
        const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
        const poop = document.createElement('button');
        poop.type = 'button';
        poop.className = 'poop';
        poop.style.left = `${clamp(x, 12, maxX)}px`;
        poop.style.top = `${clamp(y, 120, maxY)}px`;
        poop.innerText = 'ğŸ’©';
        poop.addEventListener('click', (e) => {
            e.stopPropagation();
            poop.remove();
        });
        layer.appendChild(poop);
        applyNeedsDecay(0, POOP_CLEAN_PENALTY, 0);
    }

    function cleanPoop() {
        const layer = document.getElementById('poop-layer');
        if (!layer) return;
        
        if (layer.children.length > 0) {
            if (gameState.cleanliness < CLEAN_POOP_MAX) {
                gameState.cleanliness = Math.min(CLEAN_POOP_MAX, gameState.cleanliness + CLEAN_POOP_RECOVER);
            }
            gameState.mood = Math.min(100, gameState.mood + 5);
            checkNeedsSpeech('clean');
            saveGame();
        } else {
            showCatSpeech("å·²ç¶“å¾ˆä¹¾æ·¨å›‰ï¼");
        }

        layer.innerHTML = '';
        spawnParticles(window.innerWidth / 2, window.innerHeight / 2, ['ğŸ§¼', 'âœ¨', 'ğŸ’§']);
        playSound('sfx-flip');
        updateRoomUI();
    }

    function openBath() {
        const scene = document.getElementById('scene-bath');
        if (!scene) return;
        scene.classList.remove('hidden');
        initBath();
        playSound('sfx-flip');
    }

    function closeBath() {
        const scene = document.getElementById('scene-bath');
        if (scene) scene.classList.add('hidden');
    }

    function initBath() {
        bathRemaining = BATH_CLEAN_COUNT;
        updateBathRemaining();
        const zone = document.getElementById('bath-zone');
        if (!zone) return;
        zone.innerHTML = '';
        requestAnimationFrame(spawnBathGerms);
    }

    function updateBathRemaining() {
        const remainingEl = document.getElementById('bath-remaining');
        if (remainingEl) remainingEl.innerText = bathRemaining;
    }

    function spawnBathGerms() {
        const zone = document.getElementById('bath-zone');
        if (!zone) return;
        zone.innerHTML = '';
        const rect = zone.getBoundingClientRect();
        const size = 42;
        const maxX = Math.max(0, rect.width - size - 6);
        const maxY = Math.max(0, rect.height - size - 6);
        const germs = ['ğŸ¦ ', 'ğŸ«§', 'ğŸ’§'];
        for (let i = 0; i < BATH_CLEAN_COUNT; i += 1) {
            const germ = document.createElement('button');
            germ.type = 'button';
            germ.className = 'bath-germ';
            germ.innerText = pickRandom(germs);
            const x = randInt(6, maxX + 6);
            const y = randInt(6, maxY + 6);
            germ.style.left = `${x}px`;
            germ.style.top = `${y}px`;
            germ.addEventListener('click', (e) => handleBathGermClick(e));
            zone.appendChild(germ);
        }
    }

    function handleBathGermClick(e) {
        const germ = e.currentTarget;
        if (!germ) return;
        const rect = germ.getBoundingClientRect();
        germ.remove();
        playSound('sfx-pop');
        bathRemaining = Math.max(0, bathRemaining - 1);
        updateBathRemaining();
        spawnParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, ['ğŸ’¦', 'ğŸ«§', 'âœ¨']);
        if (bathRemaining <= 0) {
            finishBath();
        }
    }

    function finishBath() {
        gameState.cleanliness = 100;
        checkNeedsSpeech('clean');
        saveGame();
        closeBath();
    }

    function unlockAudioAndStart() {
        // è§£é™¤éŸ³è¨Šé–å®šï¼Œé¿å…ä¸€æ¬¡æ’­æ”¾å¤ªå¤šè²éŸ³
        const audios = [
            'bgm',
            'sfx-correct',
            'sfx-wrong',
            'sfx-meow',
            'sfx-levelup',
            'sfx-chew',
            'sfx-coin',
            'sfx-clean',
            'sfx-diamond',
            'sfx-pop',
            'sfx-spin',
            'sfx-don',
            'sfx-don-2',
            'sfx-combo-1',
            'sfx-combo-2',
            'sfx-combo-3',
            'sfx-combo-4',
            'sfx-flip',
            'sfx-angry',
            'sfx-win',
            'sfx-real-meow',
            'sfx-boss-bgm',
            'sfx-boss-hit',
            'sfx-boss-heal',
            'sfx-boss-appear',
            'sfx-treasure-step',
            'sfx-treasure-push',
            'sfx-treasure-win',
            'sfx-treasure-ding'
        ];
        audios.forEach(id => {
            try {
                const el = document.getElementById(id);
                if(el) {
                    if (id === 'bgm') {
                        if (!el.src) setRandomBgm(true);
                        el.load();
                        if (gameState.musicOn) {
                            el.volume = 0.2;
                            el.play().catch(() => {});
                        } else {
                            el.pause();
                            el.currentTime = 0;
                        }
                        return;
                    }
                    el.pause();
                    el.currentTime = 0;
                    el.load();
                }
            } catch(e) {}
        });

        preloadImages(catSprites);

        // è§£é–èªéŸ³
        try {
            const synth = window.speechSynthesis;
            const utter = new SpeechSynthesisUtterance('');
            synth.speak(utter);
        } catch(e) {}

        document.getElementById('start-screen').style.display = 'none';
        const room = document.getElementById('scene-room');
        room.classList.remove('hidden');
        setTimeout(() => room.classList.remove('opacity-0'), 50);
        startCatWalk();
    }

    // --- 2. è²“å’ªäº’å‹• ---
    function petCat(e) {
        e.stopPropagation();
        
        const isHappy = Math.random() > 0.3;
        const rect = e.target.getBoundingClientRect();
        const x = e.clientX || (rect.left + rect.width/2);
        const y = e.clientY || (rect.top + rect.height/2);
        
        const icon = document.createElement('div');
        icon.className = 'float-icon';
        icon.style.left = (x - rect.left) + 'px';
        icon.style.top = (y - rect.top) + 'px';

        const catContainer = document.getElementById('cat-container');
        
        if (isHappy) {
            try {
                const happyUrl = normalizeAudioSrc(pickRandom(HAPPY_MEOW_LIST));
                const realMeow = document.getElementById('sfx-real-meow');
                if (realMeow && happyUrl) {
                    realMeow.src = happyUrl;
                    realMeow.load();
                    realMeow.currentTime = 0;
                    realMeow.play().catch(() => playSound('sfx-meow'));
                } else {
                    playSound('sfx-meow');
                }
            } catch(e) {
                playSound('sfx-meow');
            }

            icon.innerText = "â¤ï¸";
            icon.style.color = "#ff4757";
            catContainer.classList.remove('cat-angry');
            spawnParticles(x, y, ['â¤ï¸', 'ğŸ˜»', 'ğŸ¾']);
            gameState.mood = Math.min(100, gameState.mood + 5);
            checkNeedsSpeech('pet');
            saveGame();
            updateRoomUI();
            if (Math.random() < 0.12) {
                spawnParticles(x, y, ['âœ¨', 'ğŸ€', 'ğŸ']);
                showCatSpeech(null, 'pet');
            }
        } else {
            try {
                const angryUrl = normalizeAudioSrc(pickRandom(ANGRY_MEOW_LIST));
                const angryMeow = document.getElementById('sfx-angry');
                if (angryMeow && angryUrl) {
                    angryMeow.src = angryUrl;
                    angryMeow.load();
                    angryMeow.currentTime = 0;
                    angryMeow.play().catch(() => playSound('sfx-angry'));
                } else {
                    playSound('sfx-angry');
                }
            } catch(e) {
                playSound('sfx-angry');
            }
            icon.innerText = "ğŸ’¢";
            icon.style.color = "#2f3542";
            catContainer.classList.remove('cat-angry'); 
            void catContainer.offsetWidth; 
            catContainer.classList.add('cat-angry');
            spawnParticles(x, y, ['ğŸ’¢', 'âš¡', 'ğŸ™€']);
            showCatSpeech(null, 'pet');
        }

        catContainer.appendChild(icon);
        setTimeout(() => icon.remove(), 1000);
    }

    function feedCat(e) {
        if (gameState.isSick) {
            alert("è²“å’ªç”Ÿç—…äº†ï¼Œåƒä¸ä¸‹æ±è¥¿ï¼ğŸ’Š\nè«‹å…ˆå»å•†åº—è²·è—¥æ°´ã€‚");
            return;
        }
        if (gameState.satiety >= 100) {
            showCatSpeech("æˆ‘é£½äº†ï½å—ï¼");
            return;
        }
        if (gameState.food <= 0) {
            alert("ç½é ­ä¸å¤ äº†ï¼å¿«å»ã€Œå»æ‰“å·¥ã€è³ºç½é ­å§ï¼");
            return;
        }

        gameState.food--;
        gameState.satiety = Math.min(100, gameState.satiety + 20);
        gameState.exp += 1;
        checkNeedsSpeech('feed');
        playSound('sfx-chew');

        const rect = e?.target?.getBoundingClientRect();
        const x = rect ? rect.left + rect.width / 2 : window.innerWidth / 2;
        const y = rect ? rect.top : window.innerHeight / 2;
        spawnParticles(x, y, ['ğŸŸ', 'ğŸ˜‹', 'âœ¨']);

        const calculatedLevel = Math.floor(gameState.exp / EXP_PER_LEVEL) + 1;

        if (calculatedLevel > gameState.level) {
            gameState.level = calculatedLevel;
            unlockCatSkin(calculatedLevel - 1, true);
            showLevelUp();
        }

        saveGame();
    }

    function showLevelUp() {
        playSound('sfx-levelup');
        const overlay = document.getElementById('levelup-overlay');
        overlay.classList.remove('hidden');
        setTimeout(() => {
            overlay.classList.add('hidden');
        }, 3000);
    }

    // --- å•†åº—ç³»çµ± ---
    function openShop() {
        const shop = document.getElementById('scene-shop');
        if (shop) shop.classList.remove('hidden');
        renderShop();
        playClickSfx();
    }

    function closeShop() {
        const shop = document.getElementById('scene-shop');
        if (shop) shop.classList.add('hidden');
        playClickSfx();
    }

    function renderShop() {
        const list = document.getElementById('shop-list');
        const foodDisplay = document.getElementById('shop-food-display');
        if (!list || !foodDisplay) return;
        foodDisplay.innerText = gameState.food;
        list.innerHTML = '';

        shopItems.forEach((item) => {
            const isConsumable = item.consumable === true;
            const isOwned = !isConsumable && gameState.inventory.includes(item.id);
            const canAfford = gameState.food >= item.price;
            const row = document.createElement('div');
            row.className = `flex items-center justify-between p-3 rounded-xl border-2 ${isOwned ? 'bg-green-50 border-green-200' : 'bg-gray-50 border-gray-200'}`;

            const buttonHtml = isOwned
                ? '<span class="px-4 py-2 bg-gray-200 text-gray-500 rounded-lg font-bold text-sm">å·²æ“æœ‰</span>'
                : `<button onclick="buyItem('${item.id}', ${item.price}, event)" class="px-4 py-2 rounded-lg font-bold text-sm transition btn-3d border-b-4 ${canAfford ? 'bg-purple-500 text-white border-purple-700 hover:bg-purple-600' : 'bg-gray-300 text-gray-500 border-gray-400 cursor-not-allowed'}" ${canAfford ? '' : 'disabled'}>ğŸ’° ${item.price}</button>`;

            row.innerHTML = `
                <div class="flex items-center gap-3">
                    <div class="text-4xl bg-white p-2 rounded-lg shadow-sm">${item.icon}</div>
                    <div>
                        <h3 class="font-bold text-gray-800">${item.name}</h3>
                        <p class="text-xs text-gray-500">${item.desc}</p>
                        ${item.id === 'item-treasure-ticket' ? `<p class="text-[10px] text-emerald-600">æŒæœ‰ï¼š${gameState.treasureTickets || 0} å¼µ</p>` : ''}
                        ${item.effectDesc ? `<p class="text-[10px] text-indigo-500">${item.effectDesc}</p>` : ''}
                    </div>
                </div>
                ${buttonHtml}
            `;
            list.appendChild(row);
        });
    }

    function buyItem(itemId, price, evt) {
        if (itemId === 'item-medicine') {
            if (!gameState.isSick && gameState.satiety > 50 && gameState.mood > 50) {
                alert("è²“å’ªå¾ˆå¥åº·ï¼Œä¸éœ€è¦åƒè—¥ï¼");
                return;
            }
            if (gameState.food < price) {
                playSound('sfx-wrong');
                return;
            }
            gameState.food -= price;
            gameState.isSick = false;
            gameState.satiety = 100;
            gameState.mood = 100;
            gameState.cleanliness = 100;
            checkNeedsSpeech('medicine');

            playSound('sfx-heal');
            alert("è²“å’ªåº·å¾©äº†ï¼ç²¾ç¥ç™¾å€ï¼âœ¨");
            saveGame();
            renderShop();
            updateRoomUI();

            const rect = evt?.target?.getBoundingClientRect();
            const x = rect ? rect.left + rect.width / 2 : window.innerWidth / 2;
            const y = rect ? rect.top : window.innerHeight / 2;
            spawnParticles(x, y, ['ğŸ’Š', 'ğŸ’–', 'âœ¨']);
            return;
        }
        if (itemId === 'item-treasure-ticket') {
            if (gameState.food < price) {
                playSound('sfx-wrong');
                return;
            }
            gameState.food -= price;
            gameState.treasureTickets = (gameState.treasureTickets || 0) + 1;
            saveGame();
            renderShop();
            updateRoomUI();
            playSound('sfx-correct');
            const rect = evt?.target?.getBoundingClientRect();
            const x = rect ? rect.left + rect.width / 2 : window.innerWidth / 2;
            const y = rect ? rect.top : window.innerHeight / 2;
            spawnParticles(x, y, ['ğŸŸï¸', 'ğŸ¥«', 'âœ¨']);
            return;
        }

        if (gameState.inventory.includes(itemId)) return;
        if (gameState.food < price) {
            playSound('sfx-wrong');
            return;
        }

        gameState.food -= price;
        gameState.inventory.push(itemId);
        saveGame();
        renderShop();
        playSound('sfx-correct');

        const rect = evt?.target?.getBoundingClientRect();
        const x = rect ? rect.left + rect.width / 2 : window.innerWidth / 2;
        const y = rect ? rect.top : window.innerHeight / 2;
        spawnParticles(x, y, ['ğŸ‰', 'ğŸ’°', 'âœ¨']);
    }

    // --- åˆæˆç³»çµ± ---
    function getMaterialById(id) {
        return synthMaterials.find((item) => item.id === id);
    }

    function getSynthStyle(id) {
        return synthStyles[id] || synthStyles[0];
    }

    function setCatFilter(filterClass) {
        const catImg = document.getElementById('cat-image');
        if (!catImg) return;
        const filterClasses = ['cat-filter-ice', 'cat-filter-shadow', 'cat-filter-fire', 'cat-filter-stone'];
        catImg.classList.remove(...filterClasses);
        if (filterClass) catImg.classList.add(filterClass);
    }

    function renderSynthStyle(styleId, targetId = 'synth-stack') {
        const style = getSynthStyle(styleId);
        const container = document.getElementById(targetId);
        if (!container) return;

        if (targetId === 'synth-stack') {
            setCatFilter(style.catFilter);
        }

        container.innerHTML = '';
        if (!style.layers || style.layers.length === 0) return;

        style.layers.forEach((layer) => {
            const el = document.createElement('div');
            el.className = 'synth-layer';
            if (layer.anim) el.classList.add(layer.anim);
            if (layer.className) el.classList.add(layer.className);
            el.innerText = layer.icon;
            if (layer.size) el.style.fontSize = `${layer.size}rem`;
            if (layer.left !== undefined) el.style.left = `${layer.left}%`;
            if (layer.top !== undefined) el.style.top = `${layer.top}%`;
            if (layer.z !== undefined) el.style.zIndex = layer.z;
            if (layer.opacity !== undefined) el.style.opacity = layer.opacity;
            const transforms = ['translate(-50%, -50%)'];
            if (layer.rotate) transforms.push(`rotate(${layer.rotate}deg)`);
            if (layer.scale) transforms.push(`scale(${layer.scale})`);
            el.style.transform = transforms.join(' ');
            container.appendChild(el);
        });
    }

    function renderAreaGrid(word) {
        const grid = document.getElementById('q-grid');
        if (!grid) return;
        if (!word || !word.grid) {
            grid.classList.add('hidden');
            grid.innerHTML = '';
            return;
        }
        grid.classList.remove('hidden');
        grid.innerHTML = '';

        const buildGrid = (gridData, label, size) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'flex flex-col items-center gap-1';

            const gridEl = document.createElement('div');
            gridEl.className = 'area-grid';
            const cols = gridData.cols || 0;
            const rows = gridData.rows || 0;
            gridEl.style.gridTemplateColumns = `repeat(${cols}, ${size}px)`;
            gridEl.style.gridTemplateRows = `repeat(${rows}, ${size}px)`;
            gridEl.style.setProperty('--cell-size', `${size}px`);
            for (let i = 0; i < cols * rows; i += 1) {
                const cell = document.createElement('div');
                cell.className = 'area-cell';
                gridEl.appendChild(cell);
            }

            wrapper.appendChild(gridEl);
            if (label) {
                const tag = document.createElement('div');
                tag.className = 'text-[10px] text-gray-400';
                tag.innerText = label;
                wrapper.appendChild(tag);
            }
            return wrapper;
        };

        const grids = word.grid2 ? [word.grid, word.grid2] : [word.grid];
        const maxDim = Math.max(...grids.map((g) => Math.max(g.cols || 0, g.rows || 0)), 1);
        const baseSize = word.grid2 ? 120 : 170;
        const size = Math.max(10, Math.min(20, Math.floor(baseSize / maxDim)));

        if (word.grid2) {
            grid.appendChild(buildGrid(word.grid, 'å·¦é‚Š', size));
            grid.appendChild(buildGrid(word.grid2, 'å³é‚Š', size));
        } else {
            grid.appendChild(buildGrid(word.grid, '', size));
        }
    }

    function renderMathVisual(word) {
        const grid = document.getElementById('q-grid');
        if (!grid) return;
        if (!word || word.visual !== 'clock' || !word.time) {
            if (!grid.classList.contains('hidden')) {
                grid.classList.add('hidden');
                grid.innerHTML = '';
            }
            return;
        }
        const h = word.time.h;
        const m = word.time.m;
        const hourAngle = (h % 12) * 30 + m * 0.5;
        const minuteAngle = m * 6;
        grid.classList.remove('hidden');
        grid.innerHTML = `
            <div class="clock-wrap">
                <svg viewBox="0 0 200 200" class="clock-face" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="100" cy="100" r="92" fill="#fff" stroke="#374151" stroke-width="6"/>
                    ${Array.from({ length: 12 }).map((_, i) => {
                        const angle = i * 30 * (Math.PI / 180);
                        const x1 = 100 + 78 * Math.sin(angle);
                        const y1 = 100 - 78 * Math.cos(angle);
                        const x2 = 100 + 92 * Math.sin(angle);
                        const y2 = 100 - 92 * Math.cos(angle);
                        return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#374151" stroke-width="4"/>`;
                    }).join('')}
                    <line x1="100" y1="100" x2="100" y2="60" stroke="#f97316" stroke-width="8" stroke-linecap="round" transform="rotate(${hourAngle} 100 100)"/>
                    <line x1="100" y1="100" x2="100" y2="30" stroke="#3b82f6" stroke-width="6" stroke-linecap="round" transform="rotate(${minuteAngle} 100 100)"/>
                    <circle cx="100" cy="100" r="6" fill="#111827"/>
                </svg>
            </div>
        `;
    }

    let geneLabReady = false;

    function initGeneLab() {
        const firstInit = !geneLabReady;
        geneLabReady = true;
        renderGeneButtons('gene-eyes-panel', GENE_EYES, 'eyes');
        renderGeneButtons('gene-mouth-panel', GENE_MOUTHS, 'mouth');
        if (firstInit) {
            const hueSlider = document.getElementById('gene-hue-slider');
            const blurSlider = document.getElementById('gene-blur-slider');
            if (hueSlider) hueSlider.addEventListener('input', updateGeneFilters);
            if (blurSlider) blurSlider.addEventListener('input', updateGeneFilters);
        }
    }

    function renderGeneButtons(containerId, list, type) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';
        const ownedList = (type === 'eyes' ? gameState.geneEyeMaterials : gameState.geneMouthMaterials) || [];
        list.forEach((emoji) => {
            const btn = document.createElement('button');
            const owned = ownedList.includes(emoji);
            btn.className = `gene-btn${owned ? '' : ' locked'}`;
            btn.dataset.emoji = emoji;
            btn.textContent = owned ? emoji : 'ğŸ”’';
            btn.disabled = !owned;
            if (owned) btn.onclick = () => setGenePart(type, emoji);
            container.appendChild(btn);
        });
    }

    function setGenePart(type, emoji) {
        const ownedList = (type === 'eyes' ? gameState.geneEyeMaterials : gameState.geneMouthMaterials) || [];
        if (!ownedList.includes(emoji)) return;
        if (type === 'eyes') {
            gameState.geneEyes = emoji;
        } else {
            gameState.geneMouth = emoji;
        }
        gameState.geneActive = true;
        gameState.geneCurrentId = null;
        updateGeneProfile();
        applyGeneState();
        syncGeneControls();
        saveGame();
    }

    function updateGeneProfile() {
        const adj = pickRandom(GENE_ADJECTIVES);
        const noun = pickRandom(GENE_NOUNS);
        const code = randInt(10, 999);
        gameState.geneName = `${adj}${noun} #${code}`;
        gameState.geneDesc = pickRandom(GENE_DESCS);
    }

    function updateGeneFilters() {
        const hueSlider = document.getElementById('gene-hue-slider');
        const blurSlider = document.getElementById('gene-blur-slider');
        const hue = hueSlider ? Number(hueSlider.value) : 0;
        const blur = blurSlider ? Number(blurSlider.value) : 0;
        gameState.geneHue = hue;
        gameState.geneBlur = blur;
        gameState.geneActive = true;
        gameState.geneCurrentId = null;
        applyGeneState();
        syncGeneControls();
        saveGame();
    }

    function applyGeneState() {
        const overlay = document.getElementById('gene-overlay');
        const left = document.getElementById('gene-overlay-left');
        const right = document.getElementById('gene-overlay-right');
        if (!overlay || !left || !right) return;

        if (!gameState.geneActive) {
            overlay.classList.add('hidden');
            overlay.style.filter = '';
            return;
        }

        overlay.classList.remove('hidden');
        left.textContent = gameState.geneEyes;
        right.textContent = gameState.geneMouth;
        overlay.style.filter = `hue-rotate(${gameState.geneHue}deg) blur(${gameState.geneBlur}px)`;
    }

    function syncGeneControls() {
        renderGeneButtons('gene-eyes-panel', GENE_EYES, 'eyes');
        renderGeneButtons('gene-mouth-panel', GENE_MOUTHS, 'mouth');
        highlightGeneButtons('gene-eyes-panel', gameState.geneEyes);
        highlightGeneButtons('gene-mouth-panel', gameState.geneMouth);
        const hueVal = document.getElementById('gene-hue-val');
        const blurVal = document.getElementById('gene-blur-val');
        const hueSlider = document.getElementById('gene-hue-slider');
        const blurSlider = document.getElementById('gene-blur-slider');
        if (hueSlider) hueSlider.value = gameState.geneHue;
        if (blurSlider) blurSlider.value = gameState.geneBlur;
        if (hueVal) hueVal.textContent = `${gameState.geneHue}Â°`;
        if (blurVal) blurVal.textContent = `${gameState.geneBlur}`;

        const nameEl = document.getElementById('gene-name');
        const descEl = document.getElementById('gene-desc');
        if (nameEl) nameEl.textContent = gameState.geneName;
        if (descEl) descEl.textContent = gameState.geneDesc;
        const eyeSlot = document.getElementById('gene-eye-slot');
        const mouthSlot = document.getElementById('gene-mouth-slot');
        if (eyeSlot) eyeSlot.textContent = gameState.geneEyes;
        if (mouthSlot) mouthSlot.textContent = gameState.geneMouth;
        const fusionLeft = document.getElementById('gene-fusion-left');
        const fusionRight = document.getElementById('gene-fusion-right');
        if (fusionLeft) fusionLeft.textContent = gameState.geneEyes;
        if (fusionRight) fusionRight.textContent = gameState.geneMouth;
        switchGeneTab(activeGeneTab);
    }

    function switchGeneTab(tab) {
        activeGeneTab = tab;
        const eyesPanel = document.getElementById('gene-panel-eyes');
        const mouthPanel = document.getElementById('gene-panel-mouth');
        if (eyesPanel) eyesPanel.classList.toggle('hidden', tab !== 'eyes');
        if (mouthPanel) mouthPanel.classList.toggle('hidden', tab !== 'mouth');
        const btnEyes = document.getElementById('gene-tab-eyes');
        const btnMouth = document.getElementById('gene-tab-mouth');
        if (btnEyes) btnEyes.classList.toggle('active', tab === 'eyes');
        if (btnMouth) btnMouth.classList.toggle('active', tab === 'mouth');
    }

    function highlightGeneButtons(panelId, emoji) {
        const panel = document.getElementById(panelId);
        if (!panel) return;
        Array.from(panel.children).forEach((btn) => {
            if (btn.dataset.emoji === emoji) btn.classList.add('selected');
            else btn.classList.remove('selected');
        });
    }

    function randomGeneMutation() {
        const eyePool = gameState.geneEyeMaterials.length ? gameState.geneEyeMaterials : GENE_EYES;
        const mouthPool = gameState.geneMouthMaterials.length ? gameState.geneMouthMaterials : GENE_MOUTHS;
        gameState.geneEyes = pickRandom(eyePool);
        gameState.geneMouth = pickRandom(mouthPool);
        gameState.geneHue = randInt(0, 360);
        gameState.geneBlur = Number((Math.random() * 2).toFixed(1));
        gameState.geneActive = true;
        gameState.geneCurrentId = null;
        updateGeneProfile();
        applyGeneState();
        syncGeneControls();
        spawnParticles(window.innerWidth / 2, window.innerHeight / 2, ['âœ¨', 'ğŸ’«', 'ğŸ‰']);
        playSound('sfx-flip');
        saveGame();
    }

    function saveGeneMutation() {
        if (!gameState.geneActive) {
            return;
        }
        const mutation = {
            id: String(Date.now()),
            name: gameState.geneName,
            desc: gameState.geneDesc,
            eyes: gameState.geneEyes,
            mouth: gameState.geneMouth,
            hue: gameState.geneHue,
            blur: gameState.geneBlur
        };
        gameState.geneMutations.unshift(mutation);
        gameState.geneCurrentId = mutation.id;
        saveGame();
        renderGeneCollection();
        spawnParticles(window.innerWidth / 2, window.innerHeight / 2, ['ğŸ’¾', 'âœ¨', 'ğŸ‰']);
        playSound('sfx-levelup');
    }

    function applyGeneMutation(mutation) {
        if (!gameState.geneEyeMaterials.includes(mutation.eyes)) {
            gameState.geneEyeMaterials.push(mutation.eyes);
        }
        if (!gameState.geneMouthMaterials.includes(mutation.mouth)) {
            gameState.geneMouthMaterials.push(mutation.mouth);
        }
        gameState.geneEyes = mutation.eyes;
        gameState.geneMouth = mutation.mouth;
        gameState.geneHue = mutation.hue;
        gameState.geneBlur = mutation.blur;
        gameState.geneName = mutation.name;
        gameState.geneDesc = mutation.desc;
        gameState.geneCurrentId = mutation.id;
        gameState.geneActive = true;
        applyGeneState();
        syncGeneControls();
        saveGame();
    }

    function resetGeneMutation() {
        gameState.geneActive = false;
        gameState.geneCurrentId = null;
        gameState.geneEyes = gameState.geneEyeMaterials[0] || GENE_EYES[0];
        gameState.geneMouth = gameState.geneMouthMaterials[0] || GENE_MOUTHS[0];
        gameState.geneHue = 0;
        gameState.geneBlur = 0;
        gameState.geneName = 'ç”œç”œå°å–µ #001';
        gameState.geneDesc = 'é–ƒé–ƒç™¼äº®ã€‚';
        applyGeneState();
        syncGeneControls();
        saveGame();
    }

    function renderGeneCollection() {
        const list = document.getElementById('gene-collection-list');
        if (!list) return;
        list.innerHTML = '';
        if (!gameState.geneMutations.length) {
            list.innerHTML = '<p class="col-span-2 text-center text-gray-400 text-xs py-3">é‚„æ²’æœ‰æ”¶è—çš„é­”æ³•é€ å‹ã€‚</p>';
            return;
        }

        gameState.geneMutations.forEach((mutation) => {
            const isActive = gameState.geneCurrentId === mutation.id;
            const card = document.createElement('button');
            card.className = `p-2 rounded-xl border-2 flex flex-col items-center gap-1 transition ${isActive ? 'border-indigo-500 bg-indigo-50' : 'border-gray-200 bg-white hover:border-indigo-300'}`;
            card.innerHTML = `
                <div class="text-2xl">${mutation.eyes}${mutation.mouth}</div>
                <div class="text-[10px] font-bold text-center">${mutation.name}</div>
            `;
            card.onclick = () => applyGeneMutation(mutation);
            list.appendChild(card);
        });
    }

    function openSynthesis() {
        const panel = document.getElementById('scene-synthesis');
        if (panel) panel.classList.remove('hidden');
        gameState.synthHasNew = false;
        saveGame();
        resetCraftSlot();
        switchSynthesisTab('synth-tab-craft');
        renderSynthStyle(gameState.synthCurrent, 'synth-preview');
        playClickSfx();
    }

    function closeSynthesis() {
        const panel = document.getElementById('scene-synthesis');
        if (panel) panel.classList.add('hidden');
        resetCraftSlot();
        playClickSfx();
    }

    function openCatBook() {
        const panel = document.getElementById('scene-catbook');
        if (panel) panel.classList.remove('hidden');
        renderCatBook();
        playClickSfx();
    }

    function closeCatBook() {
        const panel = document.getElementById('scene-catbook');
        if (panel) panel.classList.add('hidden');
        playClickSfx();
    }

    function summonCat(index) {
        const safeIndex = clampCatIndex(index);
        if (!gameState.unlockedCats.includes(safeIndex)) return;
        gameState.currentCatIndex = safeIndex;
        saveGame();
        updateRoomUI();
        playSound('sfx-flip');
    }

    function renderCatBook() {
        const list = document.getElementById('catbook-list');
        const progress = document.getElementById('catbook-progress');
        if (!list || !progress) return;
        list.innerHTML = '';

        const total = catSprites.length;
        const unlocked = gameState.unlockedCats.length;
        progress.innerText = `${unlocked}/${total}`;

        for (let i = 0; i < total; i += 1) {
            const isUnlocked = gameState.unlockedCats.includes(i);
            const isEquipped = gameState.currentCatIndex === i;
            const card = document.createElement('button');
            let className = 'aspect-square rounded-2xl border-2 flex flex-col items-center justify-center relative transition-all duration-200 select-none ';
            if (isUnlocked) {
                className += 'bg-white cursor-pointer hover:scale-105 hover:shadow-md hover:border-amber-300 ';
                className += isEquipped ? 'border-green-500 bg-green-50 ring-2 ring-green-100 z-10' : 'border-amber-100 text-gray-600';
            } else {
                className += 'bg-gray-200 border-gray-300 opacity-60 cursor-not-allowed';
            }
            card.className = className;

            if (isUnlocked) {
                const badge = isEquipped
                    ? '<div class="absolute -top-2 -right-2 bg-green-500 text-white text-[10px] font-bold px-2 py-0.5 rounded-full shadow-sm border border-white">ä½¿ç”¨ä¸­</div>'
                    : '';
                card.innerHTML = `
                    ${badge}
                    <img src="${catSprites[i]}" alt="Cat ${i + 1}" class="w-16 h-16 object-contain drop-shadow-sm" loading="lazy">
                    <div class="text-[10px] font-bold text-center text-gray-600 mt-1">Lv.${i + 1}</div>
                `;
                card.onclick = () => {
                    summonCat(i);
                    renderCatBook();
                };
            } else {
                card.innerHTML = `
                    <div class="text-2xl grayscale mb-1">ğŸ”’</div>
                    <div class="text-[10px] font-bold text-gray-400">???</div>
                `;
            }
            list.appendChild(card);
        }
    }

    function switchSynthesisTab(tabId) {
        const craft = document.getElementById('synth-tab-craft');
        const collection = document.getElementById('synth-tab-collection');
        const gene = document.getElementById('synth-tab-gene');
        if (!craft || !collection || !gene) return;
        craft.classList.add('hidden');
        collection.classList.add('hidden');
        gene.classList.add('hidden');
        document.getElementById(tabId).classList.remove('hidden');

        const btnCraft = document.getElementById('btn-synth-tab-craft');
        const btnCollection = document.getElementById('btn-synth-tab-collection');
        const btnGene = document.getElementById('btn-synth-tab-gene');
        if (tabId === 'synth-tab-craft') {
            btnCraft.className = 'flex-1 py-2 rounded-md font-bold text-sm bg-white shadow-sm text-indigo-600 transition';
            btnCollection.className = 'flex-1 py-2 rounded-md font-bold text-sm text-gray-400 hover:bg-white/50 transition';
            btnGene.className = 'flex-1 py-2 rounded-md font-bold text-sm text-gray-400 hover:bg-white/50 transition';
            renderMaterialInventory();
        } else if (tabId === 'synth-tab-collection') {
            btnCollection.className = 'flex-1 py-2 rounded-md font-bold text-sm bg-white shadow-sm text-indigo-600 transition';
            btnCraft.className = 'flex-1 py-2 rounded-md font-bold text-sm text-gray-400 hover:bg-white/50 transition';
            btnGene.className = 'flex-1 py-2 rounded-md font-bold text-sm text-gray-400 hover:bg-white/50 transition';
            renderWardrobe();
        } else {
            btnGene.className = 'flex-1 py-2 rounded-md font-bold text-sm bg-white shadow-sm text-indigo-600 transition';
            btnCraft.className = 'flex-1 py-2 rounded-md font-bold text-sm text-gray-400 hover:bg-white/50 transition';
            btnCollection.className = 'flex-1 py-2 rounded-md font-bold text-sm text-gray-400 hover:bg-white/50 transition';
            initGeneLab();
            syncGeneControls();
            renderGeneCollection();
        }
    }

    function renderMaterialInventory() {
        const list = document.getElementById('material-list');
        const msg = document.getElementById('synth-msg');
        if (!list) return;
        list.innerHTML = '';

        const counts = {};
        gameState.materialInventory.forEach((id) => {
            counts[id] = (counts[id] || 0) + 1;
        });
        const ids = Object.keys(counts);
        if (ids.length === 0) {
            list.innerHTML = '<p class="col-span-4 text-center text-gray-400 text-sm py-4">æ²’æœ‰ç´ æï¼Œæ‰“å·¥æˆ–æ‰“é­”ç‹å¯ç²å¾—ã€‚</p>';
            if (msg) msg.innerText = '';
            return;
        }

        ids.forEach((id) => {
            const item = getMaterialById(id);
            if (!item) return;
            const button = document.createElement('button');
            button.className = 'relative aspect-square border-2 border-gray-200 rounded-xl flex items-center justify-center text-3xl cursor-pointer hover:bg-indigo-50 hover:border-indigo-300 transition bg-white';
            button.innerText = item.icon;
            button.onclick = () => selectMaterial(item);

            const count = document.createElement('span');
            count.className = 'absolute -bottom-1 -right-1 bg-gray-800 text-white text-[10px] w-5 h-5 rounded-full flex items-center justify-center';
            count.innerText = counts[id];
            button.appendChild(count);
            list.appendChild(button);
        });
    }

    function selectMaterial(item) {
        selectedMaterial = item;
        const slot = document.getElementById('craft-slot');
        if (slot) {
            slot.innerText = item.icon;
            slot.classList.add('border-indigo-500', 'bg-indigo-100');
        }
        const btn = document.getElementById('btn-synthesize');
        if (btn) {
            btn.disabled = false;
            btn.className = 'px-4 py-2 bg-indigo-600 text-white rounded-lg font-bold shadow-md btn-3d border-b-4 border-indigo-800 active:border-indigo-600';
            btn.innerText = 'âœ¨ é–‹å§‹åˆæˆ';
        }
        const previewId = item.styleId || 0;
        renderSynthStyle(previewId, 'synth-preview');
        playSound('sfx-flip');
    }

    function resetCraftSlot() {
        selectedMaterial = null;
        const slot = document.getElementById('craft-slot');
        if (slot) {
            slot.innerText = 'â“';
            slot.className = 'w-16 h-16 border-2 border-dashed border-indigo-300 rounded-xl flex items-center justify-center text-4xl bg-white cursor-pointer';
        }
        const btn = document.getElementById('btn-synthesize');
        if (btn) {
            btn.disabled = true;
            btn.className = 'px-4 py-2 bg-gray-300 text-white rounded-lg font-bold shadow-sm';
            btn.innerText = 'åˆæˆ';
        }
        const msg = document.getElementById('synth-msg');
        if (msg) msg.innerText = '';
        renderSynthStyle(gameState.synthCurrent, 'synth-preview');
    }

    function doSynthesis() {
        const msg = document.getElementById('synth-msg');
        if (!selectedMaterial) return;
        const resultId = selectedMaterial.styleId;
        if (!resultId) {
            if (msg) msg.innerText = 'ç´ æç„¡æ³•åˆæˆæ–°çš„é€ å‹ã€‚';
            playSound('sfx-wrong');
            return;
        }

        if (!gameState.synthUnlocked.includes(resultId)) {
            gameState.synthUnlocked.push(resultId);
            gameState.synthCurrent = resultId;
            const idx = gameState.materialInventory.indexOf(selectedMaterial.id);
            if (idx >= 0) gameState.materialInventory.splice(idx, 1);
            saveGame();
            renderSynthStyle(resultId);
            if (msg) msg.innerText = `âœ¨ åˆæˆæˆåŠŸï¼ç²å¾—ã€Œ${getSynthStyle(resultId).name}ã€`;
            spawnParticles(window.innerWidth / 2, window.innerHeight / 2, ['âœ¨', 'ğŸ‰', 'ğŸ”®']);
            playSound('sfx-levelup');
            renderMaterialInventory();
            renderWardrobe();
        } else {
            gameState.synthCurrent = resultId;
            saveGame();
            renderSynthStyle(resultId);
            if (msg) msg.innerText = 'å·²æ“æœ‰è©²é€ å‹ï¼Œå·²å¹«ä½ æ›è£ã€‚';
            playSound('sfx-flip');
        }
    }

    function renderWardrobe() {
        const list = document.getElementById('synth-tab-collection');
        if (!list) return;
        list.innerHTML = '';
        gameState.synthUnlocked.forEach((styleId) => {
            const style = getSynthStyle(styleId);
            const isCurrent = gameState.synthCurrent === styleId;
            const card = document.createElement('button');
            card.className = `p-3 rounded-xl border-2 flex flex-col items-center gap-2 transition ${isCurrent ? 'border-green-500 bg-green-50' : 'border-gray-200 bg-white hover:border-indigo-300'}`;
            const icon = style.layers && style.layers.length > 0 ? style.layers[0].icon : 'ğŸ±';
            card.innerHTML = `
                <div class="text-4xl">${icon}</div>
                <div class="text-xs font-bold text-center">${style.name}</div>
            `;
            card.onclick = () => {
                gameState.synthCurrent = styleId;
                saveGame();
                renderSynthStyle(styleId);
                renderWardrobe();
                playSound('sfx-flip');
            };
            list.appendChild(card);
        });
    }

    // --- 3. å­¸ç¿’ç³»çµ± ---
    let studyQueue = [];
    let currentCardIndex = 0;
    let writeCanvas = null;
    let writeCtx = null;
    let isDrawing = false;
    let lastDrawX = 0;
    let lastDrawY = 0;
    let penIsBlack = true;
    let canvasReady = false;

    function initCanvas() {
        const canvas = document.getElementById('write-canvas');
        if (!canvas) return;
        writeCanvas = canvas;
        writeCtx = canvas.getContext('2d');
        if (!writeCtx) return;
        const size = 280;
        const ratio = window.devicePixelRatio || 1;
        canvas.style.width = `${size}px`;
        canvas.style.height = `${size}px`;
        canvas.width = size * ratio;
        canvas.height = size * ratio;
        writeCtx.setTransform(ratio, 0, 0, ratio, 0, 0);
        writeCtx.lineWidth = 8;
        writeCtx.lineJoin = 'round';
        writeCtx.lineCap = 'round';
        writeCtx.strokeStyle = penIsBlack ? '#111827' : '#ef4444';
        if (!canvasReady) {
            setupCanvasEvents(canvas);
            canvasReady = true;
        }
    }

    function setupCanvasEvents(canvas) {
        const opts = { passive: false };
        if (window.PointerEvent) {
            canvas.addEventListener('pointerdown', startDraw, opts);
            canvas.addEventListener('pointermove', drawLine, opts);
            canvas.addEventListener('pointerup', stopDraw, opts);
            canvas.addEventListener('pointerleave', stopDraw, opts);
            canvas.addEventListener('pointercancel', stopDraw, opts);
        } else {
            canvas.addEventListener('touchstart', startDraw, opts);
            canvas.addEventListener('touchmove', drawLine, opts);
            canvas.addEventListener('touchend', stopDraw, opts);
            canvas.addEventListener('touchcancel', stopDraw, opts);
            canvas.addEventListener('mousedown', startDraw);
            canvas.addEventListener('mousemove', drawLine);
            canvas.addEventListener('mouseup', stopDraw);
            canvas.addEventListener('mouseout', stopDraw);
        }
    }

    function getCanvasPos(e) {
        if (!writeCanvas) return { x: 0, y: 0 };
        const rect = writeCanvas.getBoundingClientRect();
        const point = e.touches?.[0] || e.changedTouches?.[0] || e;
        return {
            x: point.clientX - rect.left,
            y: point.clientY - rect.top
        };
    }

    function startDraw(e) {
        if (!writeCtx) return;
        e.preventDefault();
        isDrawing = true;
        const pos = getCanvasPos(e);
        lastDrawX = pos.x;
        lastDrawY = pos.y;
    }

    function drawLine(e) {
        if (!isDrawing || !writeCtx) return;
        e.preventDefault();
        const pos = getCanvasPos(e);
        writeCtx.beginPath();
        writeCtx.moveTo(lastDrawX, lastDrawY);
        writeCtx.lineTo(pos.x, pos.y);
        writeCtx.stroke();
        lastDrawX = pos.x;
        lastDrawY = pos.y;
    }

    function stopDraw() {
        isDrawing = false;
    }

    function clearCanvas() {
        if (!writeCtx || !writeCanvas) return;
        const ratio = window.devicePixelRatio || 1;
        writeCtx.clearRect(0, 0, writeCanvas.width / ratio, writeCanvas.height / ratio);
    }

    function togglePenColor() {
        penIsBlack = !penIsBlack;
        if (writeCtx) {
            writeCtx.strokeStyle = penIsBlack ? '#111827' : '#ef4444';
        }
        const btn = document.getElementById('pen-btn');
        if (btn) {
            btn.innerText = penIsBlack ? 'ç­†è‰²: é»‘' : 'ç­†è‰²: ç´…';
            btn.classList.toggle('bg-black', penIsBlack);
            btn.classList.toggle('bg-red-500', !penIsBlack);
        }
    }
    
    function openMenu() {
        playClickSfx();
        document.getElementById('scene-menu').classList.remove('hidden');
        const list = document.getElementById('lesson-list');
        list.innerHTML = '';
        
        const categories = ['åœ‹èª', 'æ•¸å­¸', 'ç¸½è¤‡ç¿’'];
        const byCategory = {};
        Object.keys(lessons).forEach((key) => {
            const lesson = lessons[key];
            const category = lesson.category || 'å…¶ä»–';
            if (!byCategory[category]) byCategory[category] = [];
            byCategory[category].push({ key, lesson });
        });

        categories.forEach((category) => {
            const items = byCategory[category];
            if (!items || items.length === 0) return;
            const header = document.createElement('div');
            header.className = 'col-span-2 text-sm font-bold text-gray-500 px-2';
            header.innerText = category;
            list.appendChild(header);

            items.forEach(({ key, lesson }) => {
                const count = lesson.count || (lesson.words ? lesson.words.length : 0);
                const unit = lesson.mode ? 'é¡Œ' : 'å­—';
                const btn = document.createElement('button');
                btn.className = "btn-3d p-4 bg-yellow-100 rounded-xl font-bold hover:bg-yellow-200 border-b-4 border-yellow-300 text-lg flex items-center justify-between";
                btn.innerHTML = `<span>ğŸ“š ${lesson.title}</span> <span class="text-sm bg-yellow-300 px-2 py-1 rounded-full text-yellow-800">${count}${unit}</span>`;
                btn.onclick = () => startLevel(key);
                list.appendChild(btn);
            });
        });
    }

    function closeMenu() {
        document.getElementById('scene-menu').classList.add('hidden');
        playClickSfx();
    }

    function startLevel(key) {
        if (gameState.isSick) {
            const medicineItem = shopItems.find((item) => item.id === 'item-medicine');
            const medicinePrice = medicineItem ? medicineItem.price : 50;
            if (gameState.food >= medicinePrice) {
                playSound('sfx-wrong');
                alert("è²“å’ªç”Ÿç—…äº†ï¼ğŸ˜·\nå®ƒæ²’è¾¦æ³•é™ªä½ è®€æ›¸ã€‚\nè«‹å»å•†åº—è²·ã€Œè¬èƒ½è—¥æ°´ã€æ²»å¥½å®ƒï¼");
                return;
            }
            alert("è²“å’ªç”Ÿç—…äº†ï¼Œä½†ç½é ­ä¸å¤ è²·è—¥æ°´ã€‚\nå…ˆå»æ‰“å·¥è³ºè—¥æ°´éŒ¢å§ï¼");
        }
        if (gameState.satiety < 10) {
            if (gameState.food > 0) {
                playSound('sfx-wrong');
                alert("è²“å’ªè‚šå­é¤“æ‰äº†... ğŸŸ\nè«‹å…ˆé¤µå®ƒåƒæ±è¥¿ï¼");
                return;
            }
            alert("è²“å’ªå¾ˆé¤“ä½†ç½é ­ä¸è¶³ã€‚\nå…ˆå»æ‰“å·¥è³ºç½é ­å§ï¼");
        }

        resetComboState();
        closeMenu();
        bossPending = false;
        isBossBattle = false;
        const lesson = lessons[key];
        if (lesson && lesson.mode === "random10") {
            studyQueue = buildRandomWords(10);
        } else if (lesson && lesson.mode === "math10") {
            studyQueue = buildMathQuestions(10);
        } else if (lesson && lesson.mode === "clock10") {
            studyQueue = buildClockQuestions(10);
        } else if (lesson && lesson.mode === "area10") {
            studyQueue = buildAreaQuestions(10);
        } else if (lesson && lesson.mode === "mix10") {
            studyQueue = buildMixedQuestions(10);
        } else {
            studyQueue = [...lesson.words].sort(() => Math.random() - 0.5);
        }
        currentCardIndex = 0;
        document.getElementById('scene-study').classList.remove('hidden');
        loadCard();
    }

    function quitStudy() {
        document.getElementById('scene-study').classList.add('hidden');
        document.getElementById('scene-boss').classList.add('hidden');
        isBossBattle = false;
        bossPending = false;
        stopBossBgm();
        resumeRoomBgm();
        window.speechSynthesis.cancel();
        resetComboState();
        startCatWalk();
    }

    function pauseRoomBgm() {
        const bgm = document.getElementById('bgm');
        if (bgm) bgm.pause();
    }

    function resumeRoomBgm() {
        const bgm = document.getElementById('bgm');
        if (bgm && gameState.musicOn) bgm.play().catch(() => {});
    }

    function startBossBgm() {
        const bossBgm = document.getElementById('sfx-boss-bgm');
        if (!bossBgm || !gameState.musicOn) return;
        if (!bossBgm.src || !currentBossBgmUrl) {
            setRandomBossBgm();
        }
        bossBgm.volume = 0.3;
        bossBgm.currentTime = 0;
        bossBgm.play().catch(() => {});
    }

    function stopBossBgm() {
        const bossBgm = document.getElementById('sfx-boss-bgm');
        if (bossBgm) {
            bossBgm.pause();
            bossBgm.currentTime = 0;
        }
        bossBgmWasPlaying = false;
    }

    // --- é­”ç‹æˆ°ç³»çµ± ---
    function prepareBossStats() {
        bossMaxHP = Math.min(BOSS_MAX_HP, BOSS_BASE_HP + (gameState.level - 1) * BOSS_HP_PER_LEVEL);
        bossDamage = Math.max(12, Math.ceil(bossMaxHP / BOSS_HITS_TO_WIN));
        bossHeal = Math.max(10, Math.ceil(bossMaxHP / BOSS_HEAL_FACTOR));
        currentBossHP = bossMaxHP;
    }

    function triggerBossEvent() {
        pauseRoomBgm();
        playSoundFor('sfx-boss-appear', 3000);
        setRandomBossBgm();
        startBossBgm();

        isBossBattle = true;
        bossPending = false;
        prepareBossStats();

        const basePool = studyQueue.length ? [...studyQueue] : buildRandomWords(10);
        const extraPool = buildRandomWords(8);
        bossQuestions = shuffle([...basePool, ...extraPool]);

        document.getElementById('scene-study').classList.add('hidden');
        document.getElementById('scene-boss').classList.remove('hidden');

        const randomSeed = Math.floor(Math.random() * 10000);
        document.getElementById('boss-image').src = `https://robohash.org/${randomSeed}?set=set2&size=300x300`;

        updateBossUI();
        loadBossQuestion();
    }

    function updateBossUI() {
        const pct = Math.max(0, Math.min(100, (currentBossHP / bossMaxHP) * 100));
        document.getElementById('boss-hp-bar').style.width = `${pct}%`;
        document.getElementById('boss-hp-text').innerText = currentBossHP;
        document.getElementById('boss-hp-max').innerText = bossMaxHP;
    }

    function loadBossQuestion() {
        if (bossQuestions.length === 0) {
            bossQuestions = buildRandomWords(5);
        }
        bossCurrentQ = bossQuestions.shift();

        document.getElementById('boss-answer-mask').classList.remove('hidden');
        document.getElementById('boss-answer-area').classList.add('hidden');

        const isMath = bossCurrentQ.type === "math";
        const isStory = bossCurrentQ.type === "story";
        const isArea = bossCurrentQ.type === "area";
        const qText = isMath ? bossCurrentQ.q : isStory ? "æƒ…å¢ƒé¡Œ" : isArea ? "é¢ç©é¡Œ" : bossCurrentQ.z;
        const wText = isStory
            ? bossCurrentQ.w
            : isMath
                ? (bossCurrentQ.h || "")
                : isArea
                    ? bossCurrentQ.w
                    : bossCurrentQ.w.split(bossCurrentQ.c).join("ï¼¿");

        document.getElementById('boss-q-zhuyin').innerText = qText;
        document.getElementById('boss-q-word').innerText = wText;
        document.getElementById('boss-a-char').innerText = (isMath || isStory || isArea) ? bossCurrentQ.a : bossCurrentQ.c;

        speak("æ”»æ“Šæº–å‚™ï¼" + (isStory ? bossCurrentQ.w : isMath ? (bossCurrentQ.h || bossCurrentQ.q) : isArea ? bossCurrentQ.w : bossCurrentQ.w));
    }

    function revealBossAnswer() {
        document.getElementById('boss-answer-mask').classList.add('hidden');
        document.getElementById('boss-answer-area').classList.remove('hidden');
        const isMath = bossCurrentQ.type === "math";
        const isStory = bossCurrentQ.type === "story";
        const isArea = bossCurrentQ.type === "area";
        const ans = (isMath || isStory || isArea) ? bossCurrentQ.a : bossCurrentQ.c;
        playSound('sfx-flip');
        speak(ans);
    }

    function attackBoss(isCorrect) {
        const bossImg = document.getElementById('boss-image');
        if (isCorrect) {
            playSound('sfx-boss-hit');
            currentBossHP = Math.max(0, currentBossHP - bossDamage);
            bossImg.classList.remove('boss-damage', 'boss-heal');
            void bossImg.offsetWidth;
            bossImg.classList.add('boss-damage');
            showBossEffect(`-${bossDamage}`, "text-red-500");
        } else {
            playSound('sfx-boss-heal');
            currentBossHP = Math.min(bossMaxHP, currentBossHP + bossHeal);
            bossImg.classList.remove('boss-damage', 'boss-heal');
            void bossImg.offsetWidth;
            bossImg.classList.add('boss-heal');
            showBossEffect(`+${bossHeal}`, "text-green-400");
        }

        updateBossUI();

        if (currentBossHP <= 0) {
            setTimeout(() => {
                isBossBattle = false;
                stopBossBgm();
                document.getElementById('scene-boss').classList.add('hidden');
                finishLevel(true);
            }, 800);
        } else {
            setTimeout(loadBossQuestion, 900);
        }
    }

    function showBossEffect(text, colorClass) {
        const ef = document.getElementById('boss-effect');
        ef.innerText = text;
        ef.className = `absolute text-6xl font-bold transition-all ${colorClass}`;
        ef.style.opacity = 1;
        ef.style.top = "20%";

        setTimeout(() => {
            ef.style.top = "10%";
            ef.style.opacity = 0;
        }, 800);
    }

    function pickMaterialDrop(isBossWin) {
        const pool = isBossWin
            ? synthMaterials.filter((item) => item.rare)
            : synthMaterials;
        if (!pool.length) return null;
        if (!isBossWin && Math.random() > 0.4) return null;
        return pool[Math.floor(Math.random() * pool.length)];
    }

    function pickMajicDrop(isBossWin) {
        if (!isBossWin && Math.random() > 0.6) return null;
        const pickType = (type) => {
            const pool = type === 'eyes' ? GENE_EYES : GENE_MOUTHS;
            const owned = (type === 'eyes' ? gameState.geneEyeMaterials : gameState.geneMouthMaterials) || [];
            const available = pool.filter((emoji) => !owned.includes(emoji));
            return { type, available };
        };
        let { type, available } = pickType(Math.random() < 0.5 ? 'eyes' : 'mouth');
        if (!available.length) {
            const alt = pickType(type === 'eyes' ? 'mouth' : 'eyes');
            type = alt.type;
            available = alt.available;
        }
        if (!available.length) return null;
        return { type, emoji: pickRandom(available) };
    }

    function spawnRoomAtmosphere() {
        const container = document.getElementById('room-atmosphere');
        if (!container || container.children.length) return;
        const count = 8;
        for (let i = 0; i < count; i += 1) {
            const el = document.createElement('div');
            el.className = 'ambient-emoji';
            el.innerText = pickRandom(ROOM_ATMOSPHERE_LIST);
            el.style.left = `${randInt(5, 95)}%`;
            el.style.top = `${randInt(5, 85)}%`;
            el.style.fontSize = `${(randInt(18, 32) / 10).toFixed(1)}rem`;
            el.style.opacity = (Math.random() * 0.25 + 0.15).toFixed(2);
            el.style.animationDuration = `${randInt(5, 9)}s`;
            el.style.animationDelay = `${randInt(0, 4)}s`;
            container.appendChild(el);
        }
    }

    function openKeySettings() {
        const modal = document.getElementById('scene-key-settings');
        const input = document.getElementById('input-api-key');
        if (!modal || !input) return;
        playClickSfx();
        const savedKey = localStorage.getItem('user_gemini_key');
        if (savedKey) input.value = savedKey;
        setApiStatus('');
        modal.classList.remove('hidden');
    }

    function closeKeySettings() {
        const modal = document.getElementById('scene-key-settings');
        if (modal) modal.classList.add('hidden');
        playClickSfx();
    }

    function saveApiKey() {
        const input = document.getElementById('input-api-key');
        if (!input) return;
        const key = input.value.trim();
        if (!key.startsWith('AIza')) {
            alert("é€™çœ‹èµ·ä¾†ä¸åƒæ­£ç¢ºçš„ Keyï¼ˆæ‡‰è©²æ˜¯ AIza é–‹é ­ï¼‰");
            return;
        }
        setApiStatus('é©—è­‰ä¸­...');
        validateApiKey(key).then((ok) => {
            if (!ok) {
                setApiStatus('é©—è­‰å¤±æ•—ï¼Œè«‹ç¢ºèªé‡‘é‘°æ˜¯å¦æ­£ç¢ºã€‚');
                setAiStatus('AIï¼šé©—è­‰å¤±æ•—', false);
                return;
            }
            localStorage.setItem('user_gemini_key', key);
            setApiStatus('é©—è­‰æˆåŠŸï¼');
            setAiStatus('AIï¼šå·²å•Ÿç”¨', true);
            alert("è¨­å®šæˆåŠŸï¼è²“å’ªè®Šè°æ˜äº†ï¼ğŸ§ âœ¨");
            closeKeySettings();
        });
    }

    function setAiStatus(text, ok) {
        const el = document.getElementById('ai-status');
        if (!el) return;
        el.innerText = text;
        if (ok === true) el.className = 'mt-2 text-[11px] text-green-600';
        else if (ok === false) el.className = 'mt-2 text-[11px] text-red-500';
        else el.className = 'mt-2 text-[11px] text-gray-400';
    }

    function setApiStatus(text) {
        const el = document.getElementById('api-key-status');
        if (!el) return;
        el.innerText = text;
    }

    function setInviteStatus(text, ok) {
        const el = document.getElementById('invite-status');
        if (!el) return;
        el.innerText = text;
        if (ok === true) el.className = 'text-[11px] text-green-600 mt-1';
        else if (ok === false) el.className = 'text-[11px] text-red-500 mt-1';
        else el.className = 'text-[11px] text-gray-400 mt-1';
    }

    function redeemInviteCode() {
        playClickSfx();
        const input = document.getElementById('invite-code');
        if (!input) return;
        const code = input.value.trim();
        if (!code) {
            setInviteStatus('è«‹å…ˆè¼¸å…¥é‚€è«‹ç¢¼ã€‚', false);
            return;
        }
        if (code !== '1070612') {
            setInviteStatus('é‚€è«‹ç¢¼éŒ¯èª¤ã€‚', false);
            return;
        }
        if (localStorage.getItem('invite_1070612_redeemed') === '1') {
            setInviteStatus('é€™çµ„é‚€è«‹ç¢¼å·²å…Œæ›éã€‚', false);
            return;
        }
        gameState.food = (gameState.food || 0) + 50;
        localStorage.setItem('invite_1070612_redeemed', '1');
        saveGame();
        updateRoomUI();
        setInviteStatus('å…Œæ›æˆåŠŸï¼å·²ç²å¾— 50 ç½é ­ã€‚', true);
        input.value = '';
    }

    async function checkForUpdate() {
        playClickSfx();
        if (!('serviceWorker' in navigator)) {
            alert('é€™å€‹ç€è¦½å™¨ä¸æ”¯æ´æ›´æ–°åŠŸèƒ½ã€‚');
            return;
        }
        try {
            const registrations = await navigator.serviceWorker.getRegistrations();
            if (!registrations.length) {
                alert('å°šæœªå®‰è£é›¢ç·šç‰ˆæœ¬ï¼Œç„¡éœ€æ›´æ–°ã€‚');
                return;
            }
            await Promise.all(registrations.map((reg) => reg.update()));
            if ('caches' in window) {
                const keys = await caches.keys();
                await Promise.all(keys.map((key) => caches.delete(key)));
            }
            alert('å·²æª¢æŸ¥æ›´æ–°ï¼Œå°‡é‡æ–°æ•´ç†ã€‚');
            window.location.reload();
        } catch (error) {
            console.warn('Update check failed:', error);
            alert('æ›´æ–°æª¢æŸ¥å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚');
        }
    }

    async function validateApiKey(key) {
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${key}`;
        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: 'ping' }] }]
                })
            });
            const data = await response.json();
            return !data.error;
        } catch (error) {
            return false;
        }
    }

    function getCatPersonality() {
        return CAT_PERSONALITIES[gameState.currentCatIndex] || 'å¯æ„›ã€é»äººã€å¾ˆæœ‰è‡ªå·±çš„æƒ³æ³•';
    }

    function getEventHint(reason, context) {
        const sourceLabels = {
            feed: 'é¤µé£Ÿå¾Œ',
            clean: 'æ¸…ç†å¾Œ',
            pet: 'æ‘¸æ‘¸å¾Œ',
            decay: 'æ”¾è‘—ä¸€æ®µæ™‚é–“å¾Œ',
            medicine: 'åƒè—¥å¾Œ',
            offline: 'å›ä¾†æ™‚'
        };
        const sourceText = context.source ? (sourceLabels[context.source] || context.source) : '';
        const hints = {
            'answer-correct': 'å°æœ‹å‹å‰›å‰›ç­”å°äº†ä¸€é¡Œ',
            'answer-wrong': 'å°æœ‹å‹å‰›å‰›ç­”éŒ¯äº†ï¼Œéœ€è¦é¼“å‹µ',
            'reward': `å‰›æ‹¿åˆ°çå‹µ ${context.amount || 0} ç½é ­`,
            'decor-change': context.itemName ? `ä¸»äººæ›äº†è£é£¾ï¼š${context.itemName}` : 'ä¸»äººæ›´æ›äº†æˆ¿é–“è£é£¾',
            'status-change': context.changeSummary
                ? `${sourceText}ç‹€æ…‹è®ŠåŒ–ï¼š${context.changeSummary}`.trim()
                : `${sourceText}ç‹€æ…‹æœ‰è®ŠåŒ–`.trim(),
            'user-chat': context.userText ? `ä¸»äººèªªï¼šã€Œ${context.userText}ã€` : 'ä¸»äººæ­£åœ¨è·Ÿä½ èŠå¤©',
            'pet': 'ä¸»äººæ‘¸æ‘¸ä½ ',
            'feed': 'ä¸»äººé¤µä½ åƒæ±è¥¿',
            'clean': 'ä¸»äººæŠŠæˆ¿é–“æ¸…ä¹¾æ·¨äº†'
        };
        return hints[reason] || 'æ­£åœ¨å’Œä¸»äººäº’å‹•';
    }

    function buildCatPrompt(reason, context) {
        const hour = new Date().getHours();
        const userText = context.userText ? context.userText.slice(0, 60) : '';
        return `
ã€è§’è‰²è¨­å®šã€‘
ä½ ä¸æ˜¯ AIï¼Œä½ æ˜¯ä½åœ¨éŠæˆ²è£¡çš„ä¸€éš»è²“å’ªã€‚
ã€ä½ çš„å€‹æ€§ã€‘
${getCatPersonality()}
ã€å­—æ•¸é™åˆ¶ã€‘
è«‹ç”¨ç¹é«”ä¸­æ–‡ï¼Œ20å­—ä»¥å…§ã€‚
ã€å®‰å…¨è¦å‰‡ã€‘
ä¸è¦æœ‰é«’è©±ã€æš´åŠ›ã€æˆäººå…§å®¹ã€‚
ã€ç›®å‰ç‹€æ…‹ã€‘
- é£½é£Ÿåº¦: ${gameState.satiety}
- å¿ƒæƒ…: ${gameState.mood}
- æ¸…æ½”åº¦: ${gameState.cleanliness}
- ç”Ÿç—…: ${gameState.isSick ? 'æ˜¯' : 'å¦'}
- ç­‰ç´š: ${gameState.level}
- ç¾åœ¨æ™‚é–“: ${hour}é»
ã€äº‹ä»¶ã€‘
${getEventHint(reason, context)}
${userText ? `ã€ä¸»äººå‰›å‰›èªªã€‘\n${userText}\n` : ''}
ã€å›æ‡‰è¦å‰‡ã€‘
- ç”Ÿç—…å°±è™›å¼±ï¼›é¤“å°±è¨ç½é ­ï¼›é«’å°±æŠ±æ€¨ã€‚
- å‡Œæ™¨(0-6é»)å¯æŠ±æ€¨è¢«åµé†’ã€‚
- ç‹€æ…‹å¾ˆå¥½æ™‚ï¼Œæ’’å¬Œæˆ–é¼“å‹µå­¸ç¿’ã€‚
${userText ? '- è«‹é‡å°ä¸»äººèªªçš„è©±å›æ‡‰ã€‚' : ''}
è«‹èªªä¸€å¥è©±ï¼š
`;
    }

    async function askGeminiCat(reason, context) {
        const userKey = localStorage.getItem('user_gemini_key');
        if (!userKey) return null;

        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${userKey}`;
        const prompt = buildCatPrompt(reason, context);

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }]
                })
            });
            const data = await response.json();
            if (data.error) {
                console.warn("AI Key å¯èƒ½éæœŸæˆ–éŒ¯èª¤:", data.error.message);
                return null;
            }
            const aiText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            return aiText ? aiText.trim() : null;
        } catch (error) {
            console.error("AI é€£ç·šå¤±æ•—:", error);
            return null;
        }
    }

    function getActiveSpeechBubble() {
        const study = document.getElementById('scene-study');
        if (study && !study.classList.contains('hidden')) {
            return document.getElementById('study-speech');
        }
        return document.getElementById('cat-speech');
    }

    function displayCatSpeech(text, durationMs = 3200) {
        const bubble = getActiveSpeechBubble();
        if (!bubble || !text) return;
        if (bubble.id === 'study-speech') {
            const speechText = document.getElementById('study-speech-text');
            if (speechText) speechText.innerText = text;
            bubble.classList.remove('hidden');
            if (catSpeechTimer) clearTimeout(catSpeechTimer);
            lastCatSpeechAt = Date.now();
            return;
        } else {
            bubble.innerText = text;
        }
        bubble.classList.remove('hidden');
        if (catSpeechTimer) clearTimeout(catSpeechTimer);
        catSpeechTimer = setTimeout(() => {
            bubble.classList.add('hidden');
        }, durationMs);
        lastCatSpeechAt = Date.now();
    }

    function updateVoiceButton(isActive) {
        const btn = document.getElementById('btn-voice-chat');
        if (!btn) return;
        const isVoiceMode = voiceChatMode === 'voice';
        const showListening = isActive && isVoiceMode;
        btn.classList.toggle('bg-teal-400', showListening);
        btn.classList.toggle('bg-teal-500', !showListening);
        if (showListening) {
            btn.innerHTML = '<span>ğŸ¤ æˆ‘åœ¨è½...</span><span class="text-xs opacity-80">èªªå®Œæœƒå›æ‡‰</span>';
            return;
        }
        if (isVoiceMode) {
            btn.innerHTML = '<span>ğŸ¤ èªªè©±</span><span class="text-xs opacity-80">é•·æŒ‰åˆ‡æ›æ–‡å­—</span>';
        } else {
            btn.innerHTML = '<span>âŒ¨ï¸ æ‰“å­—</span><span class="text-xs opacity-80">é•·æŒ‰åˆ‡æ›èªéŸ³</span>';
        }
    }

    function setVoiceChatMode(mode) {
        voiceChatMode = mode === 'text' ? 'text' : 'voice';
        if (voiceChatMode === 'text' && isListening && speechRecognizer) {
            speechRecognizer.stop();
        }
        updateVoiceButton(isListening);
    }

    function toggleVoiceMode() {
        setVoiceChatMode(voiceChatMode === 'voice' ? 'text' : 'voice');
    }

    function handleChatButton() {
        if (voiceLongPressTriggered) {
            voiceLongPressTriggered = false;
            return;
        }
        if (voiceChatMode === 'text') {
            openChatInput();
            return;
        }
        toggleVoiceChat();
    }

    function setupVoiceChatButton() {
        const btn = document.getElementById('btn-voice-chat');
        if (!btn) return;
        const startPress = () => {
            voiceLongPressTriggered = false;
            if (voiceLongPressTimer) clearTimeout(voiceLongPressTimer);
            voiceLongPressTimer = setTimeout(() => {
                voiceLongPressTriggered = true;
                toggleVoiceMode();
                if (navigator.vibrate) navigator.vibrate(20);
            }, VOICE_LONG_PRESS_MS);
        };
        const endPress = () => {
            if (voiceLongPressTimer) {
                clearTimeout(voiceLongPressTimer);
                voiceLongPressTimer = null;
            }
            if (voiceLongPressTriggered) {
                setTimeout(() => {
                    voiceLongPressTriggered = false;
                }, 300);
            }
        };

        if (window.PointerEvent) {
            btn.addEventListener('pointerdown', startPress);
            btn.addEventListener('pointerup', endPress);
            btn.addEventListener('pointerleave', endPress);
            btn.addEventListener('pointercancel', endPress);
        } else {
            btn.addEventListener('touchstart', startPress);
            btn.addEventListener('touchend', endPress);
            btn.addEventListener('touchcancel', endPress);
            btn.addEventListener('mousedown', startPress);
            btn.addEventListener('mouseup', endPress);
            btn.addEventListener('mouseleave', endPress);
        }
        btn.addEventListener('contextmenu', (e) => e.preventDefault());
        updateVoiceButton(isListening);
    }

    function openChatInput() {
        const modal = document.getElementById('scene-chat-input');
        const input = document.getElementById('input-chat-text');
        if (!modal || !input) return;
        playClickSfx();
        input.value = '';
        modal.classList.remove('hidden');
        setTimeout(() => input.focus(), 50);
    }

    function closeChatInput() {
        const modal = document.getElementById('scene-chat-input');
        if (!modal) return;
        modal.classList.add('hidden');
        playClickSfx();
    }

    function submitChatInput() {
        const input = document.getElementById('input-chat-text');
        if (!input) return;
        const text = input.value.trim();
        if (!text) {
            input.focus();
            return;
        }
        closeChatInput();
        requestCatChat(text);
    }

    function initSpeechRecognizer() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) return null;
        const recognition = new SpeechRecognition();
        recognition.lang = 'zh-TW';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;
        recognition.onstart = () => {
            isListening = true;
            updateVoiceButton(true);
        };
        recognition.onend = () => {
            isListening = false;
            updateVoiceButton(false);
        };
        recognition.onerror = () => {
            isListening = false;
            updateVoiceButton(false);
            showCatSpeech("å–µï¼Ÿæˆ‘æ²’è½æ¸…æ¥šè€¶", 'user-chat');
        };
        recognition.onresult = (event) => {
            const transcript = event.results?.[0]?.[0]?.transcript?.trim();
            if (transcript) {
                requestCatChat(transcript, { speak: true });
            }
        };
        speechRecognizer = recognition;
        return recognition;
    }

    function toggleVoiceChat() {
        if (voiceChatMode !== 'voice') {
            openChatInput();
            return;
        }
        if (!speechRecognizer) {
            if (!initSpeechRecognizer()) {
                if (!voiceUnsupportedNotice) {
                    alert("ä½ çš„ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³è¾¨è­˜åŠŸèƒ½ï¼Œå¯é•·æŒ‰åˆ‡æ›ç‚ºæ–‡å­—è¼¸å…¥ã€‚");
                    voiceUnsupportedNotice = true;
                }
                setVoiceChatMode('text');
                return;
            }
        }
        if (isListening) {
            speechRecognizer.stop();
            return;
        }
        try {
            speechRecognizer.start();
        } catch (e) {
            console.warn("Speech start error:", e);
        }
    }

    function canTriggerSpeech() {
        return !catSpeechInFlight && (Date.now() - lastCatSpeechAt >= CAT_SPEECH_COOLDOWN_MS);
    }

    const DEFAULT_SPEECH_REASONS = new Set([
        'answer-correct',
        'answer-wrong',
        'reward',
        'status-change',
        'pet',
        'feed',
        'clean',
        'medicine',
        'decay'
    ]);

    async function requestCatSpeech(reason, context = {}) {
        if (!canTriggerSpeech()) return;
        catSpeechInFlight = true;

        let text = null;
        if (!DEFAULT_SPEECH_REASONS.has(reason)) {
            text = await askGeminiCat(reason, context);
        }
        if (!text) {
            text = pickRandom(CAT_SPEECH_LIST);
        }

        displayCatSpeech(text, 3200);
        catSpeechInFlight = false;
    }

    async function requestCatChat(userText, options = {}) {
        if (catSpeechInFlight) return;
        catSpeechInFlight = true;
        const shouldSpeak = options.speak !== false;
        const trimmed = userText.slice(0, 60);
        let text = await askGeminiCat('user-chat', { userText: trimmed });
        if (!text) text = pickRandom(CAT_SPEECH_LIST);
        displayCatSpeech(text, 3600);
        if (shouldSpeak) speakCat(text);
        catSpeechInFlight = false;
    }

    function updateNeedsSnapshot() {
        lastNeedsSnapshot = {
            satiety: gameState.satiety,
            mood: gameState.mood,
            cleanliness: gameState.cleanliness
        };
    }

    function checkNeedsSpeech(source) {
        if (!lastNeedsSnapshot) {
            updateNeedsSnapshot();
            return;
        }
        if (!canTriggerSpeech()) return;
        const changes = {
            satiety: gameState.satiety - lastNeedsSnapshot.satiety,
            mood: gameState.mood - lastNeedsSnapshot.mood,
            cleanliness: gameState.cleanliness - lastNeedsSnapshot.cleanliness
        };
        const significant = Object.entries(changes).filter(([, value]) => Math.abs(value) >= NEEDS_SPEECH_THRESHOLD);
        if (!significant.length) return;

        const changeSummary = significant
            .map(([key, value]) => {
                const label = key === 'satiety' ? 'é£½é£Ÿ' : key === 'mood' ? 'å¿ƒæƒ…' : 'æ¸…æ½”';
                const sign = value > 0 ? '+' : '';
                return `${label}${sign}${value}`;
            })
            .join(' ');

        updateNeedsSnapshot();
        requestCatSpeech('status-change', { source, changeSummary });
    }

    function showCatSpeech(forceText = null, reason = 'random', context = {}) {
        if (forceText) {
            displayCatSpeech(forceText, 2000);
            return;
        }
        requestCatSpeech(reason, context);
    }

    // é¡¯ç¤ºçµç®—ç•«é¢
    function finishLevel(isBossWin = false) {
        const baseReward = isBossWin ? 1 : studyQueue.length;
        const comboReward = isBossWin ? 0 : Math.floor(comboBonus);
        const reward = baseReward + comboReward;

        const rewardTitle = document.getElementById('reward-title');
        const rewardIcon = document.getElementById('reward-icon');
        const rewardType = document.getElementById('reward-type');
        const rewardExpInfo = document.getElementById('reward-exp-info');
        const countSpan = document.getElementById('reward-count');

        pendingMaterialDrop = pickMaterialDrop(isBossWin);
        pendingMajicDrop = pickMajicDrop(isBossWin);
        const rewardExtra = document.getElementById('reward-extra');
        const rewardExtraMajic = document.getElementById('reward-extra-majic');

        if (pendingMaterialDrop) {
            rewardExtra.innerText = `ç²å¾—ç´ æï¼š${pendingMaterialDrop.icon} ${pendingMaterialDrop.name}`;
            rewardExtra.classList.remove('hidden');
        } else {
            rewardExtra.classList.add('hidden');
            rewardExtra.innerText = '';
        }

        if (pendingMajicDrop && rewardExtraMajic) {
            const label = pendingMajicDrop.type === 'eyes' ? 'çœ¼ç¥ç´ æ' : 'å˜´å·´ç´ æ';
            rewardExtraMajic.innerText = `ç²å¾—é­”æ³•ç´ æï¼š${label} ${pendingMajicDrop.emoji}`;
            rewardExtraMajic.classList.remove('hidden');
        } else if (rewardExtraMajic) {
            rewardExtraMajic.classList.add('hidden');
            rewardExtraMajic.innerText = '';
        }

        if (isBossWin) {
            stopBossBgm();
            rewardTitle.innerText = "ğŸ† æˆ°å‹é­”ç‹ï¼";
            rewardTitle.className = "text-4xl font-black text-yellow-600 mb-4 animate-bounce";
            rewardIcon.innerText = "ğŸ¥«âœ¨";
            rewardType.innerText = "é»ƒé‡‘ç½é ­";
            if (rewardExpInfo) rewardExpInfo.classList.add('hidden');
            countSpan.dataset.isGolden = "true";
            bossPending = false;
        } else {
            rewardTitle.innerText = "ğŸ‰ æ­å–œéé—œï¼";
            rewardTitle.className = "text-4xl font-black text-yellow-500 mb-4 animate-bounce";
            rewardIcon.innerText = "ğŸ¥«";
            rewardType.innerText = "ç½é ­";
            if (rewardExpInfo) {
                if (comboReward > 0) {
                    rewardExpInfo.innerText = `é€£æ“ŠåŠ æˆ +${comboReward} ç½é ­ï¼`;
                    rewardExpInfo.classList.remove('hidden');
                } else {
                    rewardExpInfo.classList.add('hidden');
                }
            }
            countSpan.dataset.isGolden = "false";
            bossPending = Math.random() < 0.1;
        }

        countSpan.innerText = reward;
        document.getElementById('scene-reward').classList.remove('hidden');
        const rewardScene = document.getElementById('scene-reward');
        rewardScene.style.display = 'flex';
        playSound('sfx-win');
        resetComboState();
    }

    // é ˜å–çå‹µä¸¦å›é¦–é 
    function collectReward(e) {
        const countSpan = document.getElementById('reward-count');
        const amount = parseInt(countSpan.innerText, 10);
        const isGolden = countSpan.dataset.isGolden === "true";

        try {
            if (pendingMaterialDrop) {
                gameState.materialInventory.push(pendingMaterialDrop.id);
                gameState.synthHasNew = true;
                pendingMaterialDrop = null;
            }
            if (pendingMajicDrop) {
                const list = pendingMajicDrop.type === 'eyes'
                    ? gameState.geneEyeMaterials
                    : gameState.geneMouthMaterials;
                if (!list.includes(pendingMajicDrop.emoji)) {
                    list.push(pendingMajicDrop.emoji);
                    gameState.synthHasNew = true;
                }
                pendingMajicDrop = null;
            }
            saveGame();
        } catch(e) { console.error("Save error"); }

        const rewardScene = document.getElementById('scene-reward');
        rewardScene.classList.add('hidden');
        rewardScene.style.display = 'none';

        const shouldSlot = !isGolden && !bossPending;
        if (shouldSlot) {
            openWorkSlot(amount, e);
            return;
        }

        applyWorkReward(amount, e);
    }

    function openWorkSlot(baseReward, e) {
        workSlotBaseReward = baseReward;
        workSlotFinalReward = 0;
        workSlotEvent = e;
        workSlotSpinning = false;

        const scene = document.getElementById('scene-slot');
        if (scene) scene.classList.remove('hidden');
        initWorkSlotMachine();
        const baseEl = document.getElementById('slot-base-reward');
        if (baseEl) baseEl.innerText = baseReward;
        const resultEl = document.getElementById('slot-result');
        if (resultEl) {
            resultEl.classList.add('hidden');
            resultEl.innerText = '';
        }
        const spinBtn = document.getElementById('slot-spin-btn');
        const claimBtn = document.getElementById('slot-claim-btn');
        if (spinBtn) spinBtn.classList.remove('hidden');
        if (claimBtn) claimBtn.classList.add('hidden');
    }

    function initWorkSlotMachine() {
        if (workSlotReady) return;
        for (let i = 1; i <= 3; i += 1) {
            const reel = document.getElementById(`slot-reel-${i}`);
            if (!reel) continue;
            let html = '';
            for (let r = 0; r < WORK_SLOT_STRIP_LENGTH; r += 1) {
                WORK_SLOT_SYMBOLS.forEach((symbol) => {
                    html += `<div class="slot-symbol">${symbol}</div>`;
                });
            }
            reel.innerHTML = html;
            resetWorkReel(reel);
        }
        workSlotReady = true;
    }

    function resetWorkReel(reel) {
        reel.style.transition = 'none';
        reel.style.transform = 'translateY(0px)';
        void reel.offsetHeight;
    }

    function spinWorkSlot() {
        if (workSlotSpinning) return;
        workSlotSpinning = true;
        playSound('sfx-spin');

        const reels = [
            document.getElementById('slot-reel-1'),
            document.getElementById('slot-reel-2'),
            document.getElementById('slot-reel-3')
        ];

        const result = pickWorkSlotResult();
        workSlotFinalReward = result.reward;

        const spinTasks = reels.map((reel, idx) => spinWorkReel(reel, result.indexes[idx], idx));

        Promise.all(spinTasks).then(() => {
            const resultEl = document.getElementById('slot-result');
            if (resultEl) {
                resultEl.innerText = result.message;
                resultEl.classList.remove('hidden');
            }
            const spinBtn = document.getElementById('slot-spin-btn');
            const claimBtn = document.getElementById('slot-claim-btn');
            if (spinBtn) spinBtn.classList.add('hidden');
            if (claimBtn) claimBtn.classList.remove('hidden');
            workSlotSpinning = false;
        });
    }

    function pickWorkSlotOutcome() {
        const roll = Math.random();
        const missChance = 0.30;
        const x5Chance = 0.02;
        const x3Chance = 0.04;
        const x2Chance = 0.08;
        const plusOutcomes = WORK_SLOT_OUTCOMES.filter((outcome) => outcome.type === 'add');

        if (roll < missChance) return WORK_SLOT_OUTCOMES.find((o) => o.id === 'miss');
        if (roll < missChance + x5Chance) return WORK_SLOT_OUTCOMES.find((o) => o.id === 'x5');
        if (roll < missChance + x5Chance + x3Chance) return WORK_SLOT_OUTCOMES.find((o) => o.id === 'x3');
        if (roll < missChance + x5Chance + x3Chance + x2Chance) return WORK_SLOT_OUTCOMES.find((o) => o.id === 'x2');

        const idx = Math.floor(Math.random() * plusOutcomes.length);
        return plusOutcomes[idx];
    }

    function spinWorkReel(reel, targetIndex, reelIndex) {
        return new Promise((resolve) => {
            if (!reel) {
                resolve();
                return;
            }
            resetWorkReel(reel);
            const delay = 180 * reelIndex;
            setTimeout(() => {
                const rounds = WORK_SLOT_SYMBOLS.length * (WORK_SLOT_STRIP_LENGTH - 3);
                const safeIndex = Math.max(0, Math.min(WORK_SLOT_SYMBOLS.length - 1, targetIndex));
                const targetPosition = (rounds + safeIndex) * WORK_SLOT_SYMBOL_HEIGHT;
                const duration = 1.8 + reelIndex * 0.45;
                reel.style.transition = `transform ${duration}s cubic-bezier(0.25, 0.1, 0.25, 1)`;
                reel.style.transform = `translateY(-${targetPosition}px)`;
                reel.classList.add('is-spinning');
                setTimeout(() => {
                    reel.classList.remove('is-spinning');
                    resolve();
                }, duration * 1000);
            }, delay);
        });
    }

    function pickWorkSlotResult() {
        const roll = Math.random();
        const missChance = 0.30;
        const x5Chance = 0.02;
        const x3Chance = 0.04;
        const x2Chance = 0.08;
        const plusOutcomes = WORK_SLOT_OUTCOMES.filter((outcome) => outcome.type === 'add');
        const missOutcome = WORK_SLOT_OUTCOMES.find((outcome) => outcome.type === 'miss');
        const x5Outcome = WORK_SLOT_OUTCOMES.find((outcome) => outcome.id === 'x5');
        const x3Outcome = WORK_SLOT_OUTCOMES.find((outcome) => outcome.id === 'x3');
        const x2Outcome = WORK_SLOT_OUTCOMES.find((outcome) => outcome.id === 'x2');

        if (roll < missChance) {
            let indexes = [
                randInt(0, WORK_SLOT_SYMBOLS.length - 1),
                randInt(0, WORK_SLOT_SYMBOLS.length - 1),
                randInt(0, WORK_SLOT_SYMBOLS.length - 1)
            ];
            while (indexes[0] === indexes[1] && indexes[1] === indexes[2]) {
                indexes[2] = randInt(0, WORK_SLOT_SYMBOLS.length - 1);
            }
            const reward = workSlotBaseReward;
            return {
                win: false,
                outcome: missOutcome,
                indexes,
                reward,
                message: `æ§“é¾œ ${missOutcome?.emoji || ''}ï¼Œç¸½å…± ${reward} ç½é ­ï¼`
            };
        }

        const winRoll = roll - missChance;
        const winTotal = 1 - missChance;
        const thresholdX5 = x5Chance / winTotal;
        const thresholdX3 = thresholdX5 + x3Chance / winTotal;
        const thresholdX2 = thresholdX3 + x2Chance / winTotal;
        const normalized = winRoll / winTotal;

        let outcome = null;
        if (normalized < thresholdX5) outcome = x5Outcome;
        else if (normalized < thresholdX3) outcome = x3Outcome;
        else if (normalized < thresholdX2) outcome = x2Outcome;
        else outcome = plusOutcomes[randInt(0, plusOutcomes.length - 1)];

        let reward = workSlotBaseReward;
        if (outcome?.type === 'add') reward = workSlotBaseReward + outcome.value;
        if (outcome?.type === 'mult') reward = workSlotBaseReward * outcome.value;
        const index = WORK_SLOT_OUTCOMES.findIndex((item) => item.id === outcome.id);
        return {
            win: true,
            outcome,
            indexes: [index, index, index],
            reward,
            message: `æŠ½åˆ° ${outcome.emoji} ${outcome.label}ï¼Œç¸½å…± ${reward} ç½é ­ï¼`
        };
    }

    function claimWorkSlot() {
        const scene = document.getElementById('scene-slot');
        if (scene) scene.classList.add('hidden');
        playSound('sfx-don-2');
        const reward = workSlotFinalReward || workSlotBaseReward;
        applyWorkReward(reward, workSlotEvent);
    }

    function applyWorkReward(amount, e) {
        try {
            gameState.food += amount;
            saveGame();
        } catch(e) {}

        const rect = e?.target?.getBoundingClientRect();
        const x = rect ? rect.left + rect.width / 2 : window.innerWidth / 2;
        const y = rect ? rect.top : window.innerHeight / 2;
        spawnParticles(x, y, ['ğŸ’°', 'ğŸ‰', 'âœ¨']);

        if (bossPending) {
            bossPending = false;
            window.speechSynthesis.cancel();
            triggerBossEvent();
            return;
        }

        document.getElementById('scene-study').classList.add('hidden');
        document.getElementById('scene-room').classList.remove('hidden');
        stopBossBgm();
        resumeRoomBgm();
        window.speechSynthesis.cancel();
        requestCatSpeech('reward', { amount, isGolden: false });
        startCatWalk();
    }

    // --- è²“å’ªå±‹æ¨¡å¼ ---
    function setRandomBackyardBackground() {
        const scene = document.getElementById('scene-backyard');
        if (!scene || !BACKYARD_BACKGROUNDS.length) return;
        const pick = BACKYARD_BACKGROUNDS[Math.floor(Math.random() * BACKYARD_BACKGROUNDS.length)];
        scene.style.backgroundImage = `url('${pick}')`;
    }

    function openBackyard() {
        const scene = document.getElementById('scene-backyard');
        const room = document.getElementById('scene-room');
        if (!scene || !room) return;

        room.classList.add('hidden');
        setRandomBackyardBackground();
        scene.classList.remove('hidden');

        const stage = document.getElementById('backyard-stage');
        if (stage) stage.innerHTML = '';
        backyardCats = [];
        backyardItems = [];
        backyardPoops = [];
        backyardDirtySince = null;
        backyardSickFromPoop = false;
        backyardSickNotified = false;
        backyardMealProgress = 0;
        backyardMealGoal = BACKYARD_MEAL_GOAL;
        backyardRewarded = false;

        updateBackyardStageRect();
        initBackyardCats();
        updateBackyardUI();

        startBackyardLoop();
        playClickSfx();
    }

    function closeBackyard() {
        const scene = document.getElementById('scene-backyard');
        const room = document.getElementById('scene-room');
        if (!scene || !room) return;
        scene.classList.add('hidden');
        room.classList.remove('hidden');

        stopBackyardLoop();

        const stage = document.getElementById('backyard-stage');
        if (stage) stage.innerHTML = '';
        backyardCats = [];
        backyardItems = [];
        backyardPoops = [];
        backyardDirtySince = null;
        backyardSickNotified = false;

        updateRoomUI();
    }

    function updateBackyardStageRect() {
        const stage = document.getElementById('backyard-stage');
        if (!stage) return;
        backyardStageRect = stage.getBoundingClientRect();
        backyardStageWidth = backyardStageRect.width;
        backyardStageHeight = backyardStageRect.height;
        backyardCats.forEach((cat) => applyBackyardCatTransform(cat));
    }

    function startBackyardLoop() {
        stopBackyardLoop();
        backyardLastTick = 0;
        const loop = (timestamp) => {
            if (!backyardLoop) return;
            if (!backyardLastTick) backyardLastTick = timestamp;
            if (timestamp - backyardLastTick >= BACKYARD_TICK_MS) {
                updateBackyardState();
                backyardLastTick = timestamp;
            }
            backyardLoop = requestAnimationFrame(loop);
        };
        backyardLoop = requestAnimationFrame(loop);
    }

    function stopBackyardLoop() {
        if (!backyardLoop) return;
        cancelAnimationFrame(backyardLoop);
        backyardLoop = null;
    }

    function updateBackyardUI() {
        const count = document.getElementById('backyard-food-count');
        if (count) count.innerText = gameState.food;
        const tickets = document.getElementById('backyard-ticket-count');
        if (tickets) tickets.innerText = gameState.backyardTickets || 0;
        updateBackyardProgressUI();
    }

    function updateBackyardProgressUI() {
        const text = document.getElementById('backyard-progress-text');
        const bar = document.getElementById('backyard-progress-bar');
        const goal = backyardMealGoal || BACKYARD_MEAL_GOAL;
        const progress = Math.min(backyardMealProgress, goal);
        const pct = goal > 0 ? (progress / goal) * 100 : 0;
        if (bar) bar.style.width = `${pct}%`;
        if (text) {
            text.innerText = backyardRewarded
                ? 'å·²ç¶“é¤µé£½ï¼Œä»Šå¤©ä¼‘æ¯'
                : `é¤µé£½é€²åº¦ ${progress}/${goal}`;
        }
    }

    function initBackyardCats() {
        const stage = document.getElementById('backyard-stage');
        if (!stage) return;
        stage.innerHTML = '';
        backyardCats = [];

        updateBackyardStageRect();
        const pool = Array.isArray(gameState.unlockedCats) ? shuffle(gameState.unlockedCats) : [0];
        const maxCats = Math.max(1, Math.min(BACKYARD_MAX_CATS, pool.length || 1));
        const catsToShow = pool.slice(0, maxCats);

        catsToShow.forEach((catIndex) => {
            const el = document.createElement('img');
            el.src = catSprites[catIndex];
            el.className = 'backyard-cat-entity';

            const x = randInt(10, 85);
            const y = randInt(20, 75);
            el.style.setProperty('--flip', Math.random() > 0.5 ? 1 : -1);

            stage.appendChild(el);
            const cat = {
                el,
                x,
                y,
                state: 'idle',
                busyUntil: 0
            };
            backyardCats.push(cat);
            backyardMoveCat(cat, x, y);
        });
    }

    function dropKibble(e) {
        const stage = document.getElementById('backyard-stage');
        if (!stage) return;
        if (e.target && e.target !== stage && e.target.closest('.backyard-item')) return;

        if (backyardRewarded || backyardMealProgress >= backyardMealGoal) {
            playSound('sfx-wrong');
            return;
        }

        if ((gameState.backyardTickets || 0) < 1) {
            playSound('sfx-wrong');
            alert('é£¼æ–™åˆ¸ä¸è¶³ï¼\nç­”é¡Œç­”å°æ‰æœƒç²å¾—é£¼æ–™åˆ¸å–”ã€‚');
            return;
        }

        gameState.backyardTickets -= 1;
        saveGame();
        updateBackyardUI();
        updateRoomUI();

        const rect = stage.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const kibble = document.createElement('div');
        kibble.className = 'kibble';
        kibble.innerText = 'ğŸ–';
        kibble.style.left = `${x - 10}px`;
        kibble.style.top = `${y - 10}px`;
        const id = `${Date.now()}-${Math.random()}`;
        kibble.dataset.id = id;
        stage.appendChild(kibble);

        const xPct = (x / rect.width) * 100;
        const yPct = (y / rect.height) * 100;
        const landY = Math.min(85, yPct + 25);

        backyardItems.push({
            id,
            el: kibble,
            x: Math.max(6, Math.min(94, xPct)),
            y: Math.max(12, Math.min(86, landY)),
            active: true,
            claimed: false
        });

        setTimeout(() => {
            const item = backyardItems.find((entry) => entry.id === id);
            if (item) item.active = false;
            if (kibble.parentNode) kibble.remove();
        }, BACKYARD_KIBBLE_LIFE_MS);

        playSound('sfx-flip');
    }

    function updateBackyardState() {
        if (!backyardCats.length) return;
        const now = Date.now();
        updateBackyardDirtyStatus(now);
        backyardItems = backyardItems.filter((item) => item.active);

        backyardCats.forEach((cat) => {
            if (cat.busyUntil && now < cat.busyUntil) return;

            const food = backyardItems.find((item) => item.active && !item.claimed);
            if (food) {
                food.claimed = true;
                backyardMoveCat(cat, food.x, food.y - 4);
                cat.state = 'eating';
                cat.busyUntil = now + BACKYARD_MOVE_MS;

                setTimeout(() => {
                    if (!food.active) return;
                    food.active = false;
                    if (food.el && food.el.parentNode) food.el.remove();

                    cat.el.classList.add('eating');
                    setTimeout(() => cat.el.classList.remove('eating'), 500);

                    if (!backyardSickFromPoop && !backyardRewarded) {
                        backyardMealProgress = Math.min(backyardMealGoal, backyardMealProgress + 1);
                        updateBackyardProgressUI();
                        if (backyardMealProgress >= backyardMealGoal) {
                            triggerBackyardReward(cat.x, cat.y);
                        }
                    }
                    playSound('sfx-chew');
                }, Math.max(300, BACKYARD_MOVE_MS - 200));
                return;
            }

            cat.state = 'idle';
            if (Math.random() < 0.35) {
                const nx = Math.max(5, Math.min(92, cat.x + randInt(-20, 20)));
                const ny = Math.max(14, Math.min(84, cat.y + randInt(-12, 12)));
                backyardMoveCat(cat, nx, ny);
                cat.busyUntil = now + BACKYARD_MOVE_MS;
            }

            if (Math.random() < BACKYARD_POOP_CHANCE) {
                spawnBackyardPoop(cat.x, cat.y);
            }
        });
    }

    function backyardMoveCat(cat, x, y) {
        const dir = x >= cat.x ? 1 : -1;
        cat.x = x;
        cat.y = y;
        applyBackyardCatTransform(cat);
        cat.el.style.setProperty('--flip', dir);
    }

    function applyBackyardCatTransform(cat) {
        if (!cat?.el) return;
        const width = backyardStageWidth || backyardStageRect?.width || window.innerWidth;
        const height = backyardStageHeight || backyardStageRect?.height || window.innerHeight;
        const px = (cat.x / 100) * width;
        const py = (cat.y / 100) * height;
        cat.el.style.setProperty('--bx', `${px}px`);
        cat.el.style.setProperty('--by', `${py}px`);
    }

    function updateBackyardDirtyStatus(now = Date.now()) {
        if (backyardPoops.length > 0) {
            if (!backyardDirtySince) backyardDirtySince = now;
            if (!backyardSickFromPoop && now - backyardDirtySince >= BACKYARD_POOP_SICK_MS) {
                backyardSickFromPoop = true;
                gameState.isSick = true;
                saveGame();
                updateRoomUI();
                if (!backyardSickNotified) {
                    backyardSickNotified = true;
                    alert('å¤ªé«’äº†...è²“å’ªç”Ÿç—…äº†ï¼Œæ¸…ç†ä¾¿ä¾¿æ‰æœƒæœ‰çå‹µï¼');
                }
            }
        } else {
            backyardDirtySince = null;
            backyardSickNotified = false;
            if (backyardSickFromPoop) {
                backyardSickFromPoop = false;
                if (gameState.satiety >= 10 && gameState.cleanliness >= 20) {
                    gameState.isSick = false;
                }
                saveGame();
                updateRoomUI();
            }
        }
    }

    function spawnBackyardReward(x, y) {
        const stage = document.getElementById('backyard-stage');
        if (!stage) return;
        const el = document.createElement('div');
        el.className = 'backyard-item';

        const roll = Math.random();
        if (roll < 0.15) {
            const material = synthMaterials[randInt(0, synthMaterials.length - 1)];
            el.innerText = 'ğŸ’';
            el.dataset.type = 'material';
            el.dataset.materialId = material?.id || '';
            el.dataset.materialIcon = material?.icon || 'ğŸ’';
            el.dataset.amount = String(BACKYARD_DIAMOND_FOOD);
        } else if (roll < 0.3) {
            el.innerText = 'ğŸ’°';
            el.dataset.type = 'food';
            el.dataset.amount = '5';
        } else {
            el.innerText = 'ğŸª™';
            el.dataset.type = 'food';
            el.dataset.amount = '2';
        }

        el.style.left = `${x}%`;
        el.style.top = `${y + 6}%`;
        el.addEventListener('click', (evt) => {
            evt.stopPropagation();
            collectBackyardItem(el);
        });

        stage.appendChild(el);
        setTimeout(() => {
            if (el.parentNode) el.remove();
        }, 10000);
    }

    function triggerBackyardReward(x, y) {
        if (backyardRewarded) return;
        backyardRewarded = true;
        updateBackyardProgressUI();

        const bursts = 4;
        for (let i = 0; i < bursts; i += 1) {
            const dx = randInt(-12, 12);
            const dy = randInt(6, 14);
            const nx = Math.max(6, Math.min(94, x + dx));
            const ny = Math.max(12, Math.min(88, y + dy));
            spawnBackyardReward(nx, ny);
        }
        playSound('sfx-coin');
    }

    function spawnBackyardPoop(x, y) {
        const stage = document.getElementById('backyard-stage');
        if (!stage) return;
        if (backyardPoops.length >= 6) return;

        const el = document.createElement('div');
        el.className = 'backyard-item poop';
        el.innerText = 'ğŸ’©';
        el.dataset.type = 'poop';
        el.dataset.id = `${Date.now()}-${Math.random()}`;
        el.style.left = `${x}%`;
        el.style.top = `${y + 6}%`;
        el.addEventListener('click', (evt) => {
            evt.stopPropagation();
            collectBackyardItem(el);
        });

        stage.appendChild(el);
        backyardPoops.push({ id: el.dataset.id, el });
        applyNeedsDecay(0, POOP_CLEAN_PENALTY, 0);
    }

    function collectBackyardItem(el) {
        if (!el || el.classList.contains('collected')) return;
        el.classList.add('collected');

        const type = el.dataset.type;
        if (type === 'poop') {
            backyardPoops = backyardPoops.filter((item) => item.id !== el.dataset.id);
            if (gameState.cleanliness < CLEAN_POOP_MAX) {
                gameState.cleanliness = Math.min(CLEAN_POOP_MAX, gameState.cleanliness + BACKYARD_CLEAN_RECOVER);
            }
            saveGame();
            updateRoomUI();
            updateBackyardDirtyStatus();
            playSound('sfx-clean');
        } else if (type === 'food') {
            const amount = parseInt(el.dataset.amount || '0', 10);
            gameState.food += amount;
            saveGame();
            updateBackyardUI();
            updateRoomUI();
            playSound('sfx-coin');
            const rect = el.getBoundingClientRect();
            spawnParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, ['ğŸ¥«', 'âœ¨', 'ğŸ’›']);
        } else if (type === 'material') {
            const materialId = el.dataset.materialId;
            if (materialId) gameState.materialInventory.push(materialId);
            const amount = parseInt(el.dataset.amount || String(BACKYARD_DIAMOND_FOOD), 10);
            if (amount > 0) gameState.food += amount;
            saveGame();
            updateBackyardUI();
            updateRoomUI();
            playSound('sfx-diamond');
            const rect = el.getBoundingClientRect();
            const icon = el.dataset.materialIcon || 'ğŸ’';
            spawnParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, [icon, 'ğŸ¥«', 'âœ¨']);
        }

        el.style.transition = 'all 0.4s ease';
        el.style.transform = 'translateY(-30px) scale(1.4)';
        el.style.opacity = '0';
        setTimeout(() => {
            if (el.parentNode) el.remove();
        }, 400);
    }

    // --- è—å¯¶å°éŠæˆ² ---
    function openTreasureGame() {
        const scene = document.getElementById('scene-treasure');
        if (!scene) return;
        if (treasureState.level === 0 && (gameState.treasureTickets || 0) <= 0) {
            playSound('sfx-wrong');
            alert('éœ€è¦è—å¯¶åˆ¸æ‰èƒ½é–‹å•Ÿè—å¯¶æ¨¡å¼ï¼\nè«‹åˆ°å•†åº—ç”¨ 5 ç½é ­å…Œæ›ä¸€å¼µã€‚');
            return;
        }
        playClickSfx();
        scene.classList.remove('hidden');
        treasureActive = true;
        primeTreasureAudio();
        initTreasureGame();
        updateTreasureTicketUI();
        if (treasureState.level === 0) {
            treasureGenerateLevel();
        }
    }

    function closeTreasureGame() {
        const scene = document.getElementById('scene-treasure');
        if (!scene) return;
        scene.classList.add('hidden');
        treasureActive = false;
        playClickSfx();
    }

    function initTreasureGame() {
        if (!treasureCanvas) {
            treasureCanvas = document.getElementById('treasure-canvas');
            if (!treasureCanvas) return;
            treasureCtx = treasureCanvas.getContext('2d');
            const size = TREASURE_TILE_SIZE * TREASURE_COLS;
            treasureCanvas.width = size;
            treasureCanvas.height = size;
            treasureCanvas.style.width = `${size}px`;
            treasureCanvas.style.height = `${size}px`;
        }
        initTreasureWheel();
        if (!treasureKeybound) {
            window.addEventListener('keydown', (e) => {
                if (!treasureActive) return;
                const key = e.key;
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'z', 'Z', 'Backspace'].includes(key)) {
                    e.preventDefault();
                }
                if (key === 'ArrowUp') treasureHandleInput(0, -1);
                if (key === 'ArrowDown') treasureHandleInput(0, 1);
                if (key === 'ArrowLeft') treasureHandleInput(-1, 0);
                if (key === 'ArrowRight') treasureHandleInput(1, 0);
                if (key === 'z' || key === 'Z' || key === 'Backspace') treasureUndoMove();
            });
            treasureKeybound = true;
        }
    }

    function initTreasureWheel() {
        const labels = document.getElementById('treasure-wheel-labels');
        if (!labels || labels.dataset.ready === 'true') return;
        labels.innerHTML = '';
        const count = TREASURE_ROULETTE_VALUES.length;
        const angleStep = 360 / count;
        const radius = 86;
        TREASURE_ROULETTE_VALUES.forEach((value, index) => {
            const angle = angleStep * index + angleStep / 2;
            const span = document.createElement('span');
            span.innerText = value === 30 ? '30' : String(value);
            span.style.transform = `rotate(${angle}deg) translate(${radius}px, -50%) rotate(${90}deg)`;
            labels.appendChild(span);
        });
        labels.dataset.ready = 'true';
    }

    function primeTreasureAudio() {
        if (treasureAudioPrimed) return;
        const ids = ['sfx-treasure-step', 'sfx-treasure-push', 'sfx-treasure-win', 'sfx-treasure-ding'];
        ids.forEach((id) => {
            try {
                const el = document.getElementById(id);
                if (!el) return;
                el.muted = true;
                el.load();
                const playPromise = el.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        el.pause();
                        el.currentTime = 0;
                        el.muted = false;
                    }).catch(() => {
                        el.muted = false;
                    });
                } else {
                    el.muted = false;
                }
            } catch (e) {}
        });
        treasureAudioPrimed = true;
    }

    function treasureGenerateLevel() {
        const actionLabel = treasureState.level === 0 ? 'é–‹å•Ÿ' : 'ä¸‹ä¸€é—œ';
        if (!consumeTreasureTicket(actionLabel)) {
            treasureShowLoading(false);
            return;
        }
        treasureShowLoading(true);
        treasureSetAiStatus('æ¼”ç®—æ³•æ­£åœ¨é‹ªè·¯...');
        treasureState.level += 1;
        treasureState.history = [];
        treasureState.done = 0;
        treasureResetWinUI();
        const win = document.getElementById('treasure-win');
        if (win) win.classList.add('hidden');

        const map = Array(TREASURE_ROWS).fill(0).map((_, y) =>
            Array(TREASURE_COLS).fill(0).map((__, x) =>
                (x === 0 || y === 0 || x === TREASURE_COLS - 1 || y === TREASURE_ROWS - 1)
                    ? TREASURE_T.WALL
                    : (Math.random() < TREASURE_WALL_DENSITY ? TREASURE_T.WALL : TREASURE_T.FLOOR)
            )
        );

        const targets = [];
        while (targets.length < TREASURE_TARGETS) {
            const tx = treasureRandInt(2, TREASURE_COLS - 3);
            const ty = treasureRandInt(2, TREASURE_ROWS - 3);
            if (map[ty][tx] === TREASURE_T.FLOOR) {
                map[ty][tx] = TREASURE_T.TARGET;
                targets.push({ x: tx, y: ty });
            }
        }

        const boxes = targets.map((t) => ({ ...t }));
        let ghost = treasurePickFloor(map);
        const pullSteps = TREASURE_PULL_BASE + (treasureState.level * 5);
        const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];

        for (let i = 0; i < pullSteps; i += 1) {
            const idx = treasureRandInt(0, boxes.length - 1);
            const box = boxes[idx];
            const dir = dirs[treasureRandInt(0, dirs.length - 1)];
            const pullX = box.x + dir[0];
            const pullY = box.y + dir[1];
            const ghostX = box.x + dir[0] * 2;
            const ghostY = box.y + dir[1] * 2;

            if (treasureIsOut(ghostX, ghostY)) continue;
            if (pullX <= 0 || pullX >= TREASURE_COLS - 1 || pullY <= 0 || pullY >= TREASURE_ROWS - 1) {
                continue;
            }
            if (ghostX <= 0 || ghostX >= TREASURE_COLS - 1 || ghostY <= 0 || ghostY >= TREASURE_ROWS - 1) {
                continue;
            }
            if (map[pullY][pullX] === TREASURE_T.WALL) map[pullY][pullX] = TREASURE_T.FLOOR;
            if (map[ghostY][ghostX] === TREASURE_T.WALL) map[ghostY][ghostX] = TREASURE_T.FLOOR;

            const stacked = boxes.some((b, bIdx) => bIdx !== idx && b.x === pullX && b.y === pullY);
            if (stacked) continue;

            box.x = pullX;
            box.y = pullY;
            ghost = { x: ghostX, y: ghostY };
        }

        for (let y = 0; y < TREASURE_ROWS; y += 1) {
            for (let x = 0; x < TREASURE_COLS; x += 1) {
                if (map[y][x] !== TREASURE_T.WALL) map[y][x] = TREASURE_T.FLOOR;
            }
        }

        targets.forEach((t) => {
            map[t.y][t.x] = TREASURE_T.TARGET;
        });
        boxes.forEach((b) => {
            map[b.y][b.x] = (map[b.y][b.x] === TREASURE_T.TARGET) ? TREASURE_T.DONE : TREASURE_T.BOX;
        });

        treasureState.map = map;
        treasureState.player = ghost;
        treasureState.goals = targets.length;
        treasureTheme = { ...TREASURE_DEFAULT_THEME };
        treasureApplyTheme(treasureTheme);
        treasureUpdateUI();
        treasureDraw();

        const key = localStorage.getItem('user_gemini_key');
        if (!key) {
            treasureSetAiStatus('ä½¿ç”¨é è¨­ä¸»é¡Œ');
            setTimeout(() => treasureShowLoading(false), 300);
            return;
        }

        treasureSetAiStatus('æˆ‘çœ‹çœ‹è¦è—ä»€éº¼å¥½...');
        fetchTreasureTheme(key).then((theme) => {
            if (theme) {
                treasureTheme = theme;
                treasureApplyTheme(treasureTheme);
            }
            treasureDraw();
            treasureShowLoading(false);
        });
    }

    function treasureHandleInput(dx, dy) {
        if (!treasureActive) return;
        const win = document.getElementById('treasure-win');
        if (win && !win.classList.contains('hidden')) return;

        const { x, y } = treasureState.player;
        const nx = x + dx;
        const ny = y + dy;
        if (treasureIsOut(nx, ny)) return;

        const tile = treasureState.map[ny][nx];
        if (tile === TREASURE_T.WALL) return;

        if (tile === TREASURE_T.FLOOR || tile === TREASURE_T.TARGET) {
            treasureMovePlayer(dx, dy);
            treasurePlaySfx('sfx-treasure-step');
        } else if (tile === TREASURE_T.BOX || tile === TREASURE_T.DONE) {
            const nnx = nx + dx;
            const nny = ny + dy;
            if (treasureIsOut(nnx, nny)) return;
            const nextTile = treasureState.map[nny][nnx];
            if (nextTile === TREASURE_T.FLOOR || nextTile === TREASURE_T.TARGET) {
                treasurePushBox(nx, ny, nnx, nny);
                treasureMovePlayer(dx, dy);
                treasurePlaySfx('sfx-treasure-push');
            }
        }

        treasureCheckWin();
        treasureDraw();
    }

    function treasureMovePlayer(dx, dy) {
        treasureState.history.push({
            map: treasureState.map.map((row) => [...row]),
            player: { ...treasureState.player }
        });
        if (treasureState.history.length > 50) treasureState.history.shift();
        treasureState.player.x += dx;
        treasureState.player.y += dy;
    }

    function treasurePushBox(fromX, fromY, toX, toY) {
        const placingOnTarget = treasureState.map[toY][toX] === TREASURE_T.TARGET;
        treasureState.map[fromY][fromX] = (treasureState.map[fromY][fromX] === TREASURE_T.DONE)
            ? TREASURE_T.TARGET
            : TREASURE_T.FLOOR;
        treasureState.map[toY][toX] = (treasureState.map[toY][toX] === TREASURE_T.TARGET)
            ? TREASURE_T.DONE
            : TREASURE_T.BOX;
        if (placingOnTarget) {
            playSound('sfx-coin');
        }
    }

    function treasureUndoMove() {
        if (treasureState.history.length === 0) return;
        const prev = treasureState.history.pop();
        treasureState.map = prev.map.map((row) => [...row]);
        treasureState.player = { ...prev.player };
        treasureDraw();
        treasureCheckWin();
    }

    function treasureCheckWin() {
        let done = 0;
        for (let y = 0; y < TREASURE_ROWS; y += 1) {
            for (let x = 0; x < TREASURE_COLS; x += 1) {
                if (treasureState.map[y][x] === TREASURE_T.DONE) done += 1;
            }
        }
        treasureState.done = done;
        treasureUpdateUI();
        if (done === treasureState.goals && done > 0) {
            const win = document.getElementById('treasure-win');
            if (win && win.classList.contains('hidden')) {
                openTreasureWin();
            }
        }
    }

    function treasureDraw() {
        if (!treasureCtx || !treasureCanvas) return;
        treasureCtx.fillStyle = treasureTheme.bgColor || TREASURE_DEFAULT_THEME.bgColor;
        treasureCtx.fillRect(0, 0, treasureCanvas.width, treasureCanvas.height);

        for (let y = 0; y < TREASURE_ROWS; y += 1) {
            for (let x = 0; x < TREASURE_COLS; x += 1) {
                const tile = treasureState.map[y][x];
                const px = x * TREASURE_TILE_SIZE;
                const py = y * TREASURE_TILE_SIZE;
                const floorColor = treasureTheme.colors?.floor || TREASURE_DEFAULT_THEME.colors.floor;
                const wallColor = treasureTheme.colors?.wall || TREASURE_DEFAULT_THEME.colors.wall;
                const doneColor = treasureTheme.colors?.done || TREASURE_DEFAULT_THEME.colors.done;

                treasureCtx.fillStyle = tile === TREASURE_T.WALL ? wallColor : floorColor;
                treasureCtx.fillRect(px, py, TREASURE_TILE_SIZE, TREASURE_TILE_SIZE);
                if (tile === TREASURE_T.WALL) {
                    treasureCtx.fillStyle = 'rgba(255, 255, 255, 0.12)';
                    treasureCtx.fillRect(px, py, TREASURE_TILE_SIZE, 4);
                }

                let emoji = '';
                if (tile === TREASURE_T.TARGET) emoji = treasureTheme.chars?.target || TREASURE_DEFAULT_THEME.chars.target;
                if (tile === TREASURE_T.BOX) emoji = treasureTheme.chars?.box || TREASURE_DEFAULT_THEME.chars.box;
                if (tile === TREASURE_T.DONE) {
                    treasureCtx.fillStyle = doneColor;
                    treasureCtx.fillRect(px, py, TREASURE_TILE_SIZE, TREASURE_TILE_SIZE);
                    emoji = treasureTheme.chars?.done || TREASURE_DEFAULT_THEME.chars.done;
                }
                if (tile === TREASURE_T.WALL && treasureTheme.chars?.wall) {
                    emoji = treasureTheme.chars.wall;
                }

                if (emoji) {
                    treasureCtx.globalAlpha = 1;
                    treasureCtx.shadowColor = 'rgba(0, 0, 0, 0.35)';
                    treasureCtx.shadowBlur = 6;
                    const objectFont = Math.round(TREASURE_TILE_SIZE * 0.75);
                    treasureCtx.font = `${objectFont}px "Apple Color Emoji", "Noto Color Emoji", "Segoe UI Emoji", sans-serif`;
                    treasureCtx.textAlign = 'center';
                    treasureCtx.textBaseline = 'middle';
                    treasureCtx.fillText(emoji, px + TREASURE_TILE_SIZE / 2, py + TREASURE_TILE_SIZE / 2 + 2);
                    treasureCtx.shadowColor = 'transparent';
                    treasureCtx.shadowBlur = 0;
                }
            }
        }

        const playerEmoji = TREASURE_DEFAULT_THEME.chars.player;
        const playerCenterX = treasureState.player.x * TREASURE_TILE_SIZE + TREASURE_TILE_SIZE / 2;
        const playerCenterY = treasureState.player.y * TREASURE_TILE_SIZE + TREASURE_TILE_SIZE / 2 + 2;
        treasureCtx.globalAlpha = 1;
        treasureCtx.globalCompositeOperation = 'source-over';
        treasureCtx.fillStyle = '#ffffff';
        treasureCtx.beginPath();
        treasureCtx.arc(playerCenterX, playerCenterY - 1, TREASURE_TILE_SIZE * 0.45, 0, Math.PI * 2);
        treasureCtx.fill();
        treasureCtx.shadowColor = 'rgba(0, 0, 0, 0.7)';
        treasureCtx.shadowBlur = 6;
        const playerFont = Math.round(TREASURE_TILE_SIZE * 0.9);
        treasureCtx.font = `${playerFont}px "Apple Color Emoji", "Noto Color Emoji", "Segoe UI Emoji", sans-serif`;
        treasureCtx.textAlign = 'center';
        treasureCtx.textBaseline = 'middle';
        treasureCtx.fillText(playerEmoji, playerCenterX, playerCenterY);
        treasureCtx.shadowColor = 'transparent';
        treasureCtx.shadowBlur = 0;
    }

    function treasureUpdateUI() {
        const level = document.getElementById('treasure-level');
        if (level) level.innerText = treasureState.level;
        const score = document.getElementById('treasure-score');
        if (score) score.innerText = `${treasureState.done}/${treasureState.goals}`;
        const progress = document.getElementById('treasure-progress');
        if (progress) {
            const pct = treasureState.goals > 0 ? (treasureState.done / treasureState.goals) * 100 : 0;
            progress.style.width = `${pct}%`;
        }
        updateTreasureTicketUI();
    }

    function treasureApplyTheme(theme) {
        const title = document.getElementById('treasure-title');
        const story = document.getElementById('treasure-story');
        if (title) title.innerText = theme?.name || TREASURE_DEFAULT_THEME.name;
        if (story) story.innerText = theme?.story || TREASURE_DEFAULT_THEME.story;
        const backdrop = document.getElementById('treasure-backdrop');
        if (backdrop && theme?.bgColor) {
            backdrop.style.backgroundColor = theme.bgColor;
        }
    }

    function updateTreasureTicketUI() {
        const el = document.getElementById('treasure-ticket-count');
        if (!el) return;
        el.innerText = gameState.treasureTickets || 0;
    }

    function consumeTreasureTicket(actionLabel) {
        const current = gameState.treasureTickets || 0;
        if (current <= 0) {
            playSound('sfx-wrong');
            alert(`éœ€è¦è—å¯¶åˆ¸æ‰èƒ½${actionLabel}ï¼\nè«‹åˆ°å•†åº—ç”¨ 5 ç½é ­å…Œæ›ä¸€å¼µã€‚`);
            return false;
        }
        gameState.treasureTickets = current - 1;
        saveGame();
        updateRoomUI();
        updateTreasureTicketUI();
        return true;
    }

    function treasureResetWinUI() {
        const reward = document.getElementById('treasure-win-reward');
        const spinBtn = document.getElementById('treasure-spin-btn');
        const nextBtn = document.getElementById('treasure-next-btn');
        const wheel = document.getElementById('treasure-wheel');
        if (reward) reward.classList.add('hidden');
        if (spinBtn) spinBtn.classList.remove('hidden');
        if (nextBtn) nextBtn.classList.add('hidden');
        if (wheel) wheel.style.transform = 'rotate(0deg)';
        treasureWheelRotation = 0;
        treasureSpinInProgress = false;
    }

    function openTreasureWin() {
        const win = document.getElementById('treasure-win');
        if (win) win.classList.remove('hidden');
        treasureResetWinUI();
        treasurePlaySfx('sfx-treasure-win', 'sfx-win');
    }

    function spinTreasureRoulette() {
        if (treasureSpinInProgress) return;
        treasureSpinInProgress = true;
        const spinBtn = document.getElementById('treasure-spin-btn');
        const nextBtn = document.getElementById('treasure-next-btn');
        const rewardEl = document.getElementById('treasure-win-reward');
        const wheel = document.getElementById('treasure-wheel');
        if (!wheel) return;
        if (spinBtn) spinBtn.classList.add('hidden');

        const baseReward = 3;
        const hitSpecial = Math.random() < 0.03;
        const extraReward = hitSpecial ? 30 : treasureRandInt(0, 10);
        const reward = baseReward + extraReward;
        const targetIndex = TREASURE_ROULETTE_VALUES.indexOf(extraReward);
        const segment = 360 / TREASURE_ROULETTE_VALUES.length;
        const baseAngle = 360 - (targetIndex * segment + segment / 2);
        const extraSpins = 360 * (3 + treasureRandInt(0, 2));
        treasureWheelRotation = treasureWheelRotation + extraSpins + baseAngle;
        wheel.style.transform = `rotate(${treasureWheelRotation}deg)`;

        setTimeout(() => {
            gameState.food += reward;
            saveGame();
            updateRoomUI();
            if (rewardEl) {
                rewardEl.innerText = `ç²å¾— ${baseReward}+${extraReward} ç½é ­ï¼`;
                rewardEl.classList.remove('hidden');
            }
            if (nextBtn) nextBtn.classList.remove('hidden');
            treasureSpinInProgress = false;
        }, 3200);
    }

    async function fetchTreasureTheme(key) {
        const seeds = ['ç§‘å¹»', 'é­”æ³•', 'ç¾é£Ÿ', 'æµ·åº•', 'å‹•ç‰©', 'æ£®æ—', 'å°ç£å¤œå¸‚', 'å¤ªç©º', 'ç«¥è©±'];
        const seed = seeds[Math.floor(Math.random() * seeds.length)];
        const prompt = `
Design a theme for a Sokoban puzzle game level.
Seed keyword: "${seed}".
Return JSON only:
{
  "name": "Level title (max 6 words)",
  "story": "A short, cute story (max 20 words, Chinese)",
  "bgColor": "#HexColor",
  "colors": { "floor": "#Hex", "wall": "#Hex", "done": "rgba(...)" },
  "chars": { "wall": "", "player": "ğŸˆ", "box": "ğŸ“¦", "target": "âŒ", "done": "ğŸ" }
}`;
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${key}`;
        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }]
                })
            });
            const data = await response.json();
            if (data.error) return null;
            const rawText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
            const cleaned = rawText.replace(/```json|```/g, '').trim();
            const parsed = JSON.parse(cleaned);
            parsed.chars = { ...TREASURE_DEFAULT_THEME.chars, ...parsed.chars, player: TREASURE_DEFAULT_THEME.chars.player };
            return parsed;
        } catch (error) {
            return null;
        }
    }

    function treasureShowLoading(show) {
        const mask = document.getElementById('treasure-mask');
        if (!mask) return;
        mask.classList.toggle('hidden', !show);
    }

    function treasureSetAiStatus(text) {
        const el = document.getElementById('treasure-ai-status');
        if (el) el.innerText = text;
    }

    function treasurePlaySfx(id, fallbackId) {
        const el = document.getElementById(id);
        if (!el) return;
        el.currentTime = 0;
        const promise = el.play();
        if (promise !== undefined) {
            promise.catch(() => {
                if (fallbackId) playSound(fallbackId);
            });
        }
    }

    function treasureIsOut(x, y) {
        return x < 0 || x >= TREASURE_COLS || y < 0 || y >= TREASURE_ROWS;
    }

    function treasurePickFloor(map) {
        while (true) {
            const x = treasureRandInt(1, TREASURE_COLS - 2);
            const y = treasureRandInt(1, TREASURE_ROWS - 2);
            if (map[y][x] === TREASURE_T.FLOOR) return { x, y };
        }
    }

    function treasureRandInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function loadCard() {
        if (currentCardIndex >= studyQueue.length) {
            finishLevel(false);
            return;
        }

        const word = studyQueue[currentCardIndex];
        const cardInner = document.getElementById('study-card');
        
        cardInner.classList.remove('card-flipped');
        document.getElementById('study-controls').classList.add('hidden');
        document.getElementById('tap-hint').classList.remove('hidden'); 

        document.getElementById('q-idx').innerText = currentCardIndex + 1;

        const isMath = word.type === "math";
        const isStory = word.type === "story";
        const isArea = word.type === "area";
        const isClock = isMath && word.visual === "clock";
        const shouldShowWriting = !isMath && !isStory && !isArea;
        const studyScene = document.getElementById('scene-study');
        if (studyScene) {
            studyScene.classList.toggle('story-mode', isStory);
            studyScene.classList.toggle('area-mode', isArea);
            studyScene.classList.toggle('clock-mode', isClock);
            studyScene.classList.toggle('math-mode', isMath && !isStory && !isArea);
            studyScene.classList.toggle('writing-mode', shouldShowWriting);
        }
        const writingArea = document.getElementById('writing-area');
        if (writingArea) {
            writingArea.classList.toggle('hidden', !shouldShowWriting);
            if (shouldShowWriting) {
                initCanvas();
                clearCanvas();
            }
        }
        const questionText = isMath ? word.q : isStory ? "æƒ…å¢ƒé¡Œ" : isArea ? "é¢ç©é¡Œ" : word.z;
        const answerText = isMath || isStory || isArea ? word.a : word.c;
        const radicalText = isMath || isStory || isArea ? "æ•¸å­¸é¡Œ" : word.r;
        const maskedWord = isStory ? word.w : isMath ? (word.h || "") : isArea ? word.w : word.w.split(word.c).join("ï¼¿");

        document.getElementById('q-zhuyin').innerText = questionText;
        const hintEl = document.getElementById('q-hint');
        hintEl.innerText = maskedWord;
        hintEl.classList.toggle('story-hint', isStory);
        hintEl.classList.toggle('area-hint', isArea);
        hintEl.classList.toggle('hidden', isClock && !maskedWord);

        document.getElementById('q-char').innerText = answerText;
        document.getElementById('q-radical').innerText = radicalText;
        document.getElementById('a-word').innerText = word.w;

        const pct = (currentCardIndex / studyQueue.length) * 100;
        document.getElementById('study-progress').style.width = `${pct}%`;

        renderAreaGrid(isArea ? word : null);
        if (isClock) {
            renderMathVisual(word);
        }
        const speakText = isStory ? word.w : isMath ? (word.h || word.q) : isArea ? word.w : word.w;
        speak(speakText);
    }

    function flipCard() {
        const cardInner = document.getElementById('study-card');
        
        if (!cardInner.classList.contains('card-flipped')) {
            cardInner.classList.add('card-flipped');
            document.getElementById('study-controls').classList.remove('hidden');
            document.getElementById('tap-hint').classList.add('hidden'); 
            
            playSound('sfx-flip');
            
            const word = studyQueue[currentCardIndex];
            const isMath = word.type === "math";
            const isStory = word.type === "story";
            const isArea = word.type === "area";
            const answerText = isMath || isStory || isArea ? word.a : word.c;
            const speakText = isArea ? `${answerText}æ ¼ã€‚${word.w}` : `${answerText}ã€‚${word.w}`;
            speak(speakText);
        }
    }

    function answer(isCorrect) {
        const controls = document.getElementById('study-controls');
        controls.style.pointerEvents = 'none';
        const currentWord = studyQueue[currentCardIndex];

        if (isCorrect) {
            playSound('sfx-correct');
            gameState.backyardTickets = (gameState.backyardTickets || 0) + 1;
            saveGame();
            handleComboCorrect();
            requestCatSpeech('answer-correct', { subject: currentWord?.type || 'word' });
            currentCardIndex++;
            setTimeout(() => {
                loadCard();
                controls.style.pointerEvents = 'auto';
            }, 600);
        } else {
            playSound('sfx-wrong');
            handleComboWrong();
            requestCatSpeech('answer-wrong', { subject: currentWord?.type || 'word' });
            const word = currentWord;
            studyQueue.push(word);
            
            setTimeout(() => {
                document.getElementById('study-card').classList.remove('card-flipped');
                document.getElementById('study-controls').classList.add('hidden');
                document.getElementById('tap-hint').classList.remove('hidden');
                
                const retryText = word.type === "math"
                    ? (word.h || word.q)
                    : word.type === "story"
                        ? word.w
                        : word.type === "area"
                            ? word.w
                            : word.z;
                speak("å†è©¦ä¸€æ¬¡: " + retryText);
                controls.style.pointerEvents = 'auto';
            }, 1000);
        }
    }

    // --- 4. èªéŸ³ ---
    const synth = window.speechSynthesis;
    function getCatVoice() {
        if (!synth) return null;
        const voices = synth.getVoices();
        if (!voices || voices.length === 0) return catVoice;
        const zhVoices = voices.filter((voice) => voice.lang && voice.lang.startsWith('zh'));
        const preferred = zhVoices.find((voice) => /zh-tw/i.test(voice.lang) && /(mei[-\s]?jia|siri|taiwan)/i.test(voice.name))
            || zhVoices.find((voice) => /zh-tw/i.test(voice.lang))
            || zhVoices[0]
            || voices[0];
        catVoice = preferred;
        return catVoice;
    }

    function initCatVoice() {
        if (!synth) return;
        const refresh = () => {
            catVoice = null;
            getCatVoice();
        };
        if (typeof synth.onvoiceschanged !== 'undefined') {
            synth.onvoiceschanged = refresh;
        }
        refresh();
    }

    function syncViewportSize() {
        const vv = window.visualViewport;
        const width = vv ? vv.width : window.innerWidth;
        const height = vv ? vv.height : window.innerHeight;
        document.documentElement.style.setProperty('--app-width', `${Math.round(width)}px`);
        document.documentElement.style.setProperty('--app-height', `${Math.round(height)}px`);
    }

    function speakCat(text) {
        if (!text || !synth) return;
        try {
            if (synth.speaking) synth.cancel();
            const utter = new SpeechSynthesisUtterance(text);
            utter.lang = 'zh-TW';
            utter.rate = 1.3;
            utter.pitch = 1.4;
            const voice = getCatVoice();
            if (voice) utter.voice = voice;
            synth.speak(utter);
        } catch (e) {}
    }

    function speak(text) {
        if (synth.speaking) synth.cancel();
        
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = 'zh-TW';
        utter.rate = 0.8;
        synth.speak(utter);
    }

    function toggleMusic() {
        try {
            const bgm = document.getElementById('bgm');
            const btn = document.getElementById('btn-music');
            if (bgm.paused) {
                if (!bgm.src) setRandomBgm(false);
                bgm.volume = 0.2;
                bgm.play().catch(() => {});
                btn.innerText = "ğŸ”Š";
                gameState.musicOn = true;
            } else {
                bgm.pause();
                btn.innerText = "ğŸ”‡";
                gameState.musicOn = false;
            }
        } catch(e) {}
    }

    function handleVisibilityChange() {
        const bgm = document.getElementById('bgm');
        const bossBgm = document.getElementById('sfx-boss-bgm');
        if (document.hidden) {
            bgmWasPlaying = bgm ? !bgm.paused : false;
            bossBgmWasPlaying = bossBgm ? !bossBgm.paused : false;
            if (bgm) bgm.pause();
            if (bossBgm) bossBgm.pause();
        } else if (gameState.musicOn) {
            if (bossBgmWasPlaying && bossBgm) {
                bossBgm.play().catch(() => {});
            } else if (bgmWasPlaying && bgm) {
                bgm.play().catch(() => {});
            }
        }
    }

    // ç¢ºä¿ DOM è¼‰å…¥å¾Œæ‰åŸ·è¡Œï¼Œé¿å…æ‰¾ä¸åˆ°å…ƒç´ éŒ¯èª¤
    document.addEventListener('DOMContentLoaded', () => {
        syncViewportSize();
        loadGame();
        setRandomBgm(false);
        spawnRoomAtmosphere();
        setupVoiceChatButton();
        initCatVoice();

        const savedKey = localStorage.getItem('user_gemini_key');
        if (savedKey) {
            setAiStatus('AIï¼šé©—è­‰ä¸­...', null);
            validateApiKey(savedKey).then((ok) => {
                if (ok) setAiStatus('AIï¼šå·²å•Ÿç”¨', true);
                else setAiStatus('AIï¼šé©—è­‰å¤±æ•—', false);
            });
        } else {
            setAiStatus('AIï¼šå°šæœªè¨­å®š', null);
        }

        const bgm = document.getElementById('bgm');
        if (bgm) {
            bgm.addEventListener('ended', () => setRandomBgm(true));
            bgm.addEventListener('error', () => setRandomBgm(true));
        }
        const bossBgm = document.getElementById('sfx-boss-bgm');
        if (bossBgm) {
            bossBgm.addEventListener('ended', () => {
                if (isBossBattle && gameState.musicOn) {
                    setRandomBossBgm();
                    bossBgm.play().catch(() => {});
                }
            });
        }

        document.addEventListener('visibilitychange', handleVisibilityChange);
        window.addEventListener('resize', updateBackyardStageRect);
        window.addEventListener('resize', syncViewportSize);
        window.addEventListener('orientationchange', syncViewportSize);
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', syncViewportSize);
            window.visualViewport.addEventListener('scroll', syncViewportSize);
        }
        window.addEventListener('pagehide', () => {
            const bgmEl = document.getElementById('bgm');
            if (bgmEl) bgmEl.pause();
            const bossBgmEl = document.getElementById('sfx-boss-bgm');
            if (bossBgmEl) bossBgmEl.pause();
        });
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.js').catch(() => {});
        }
    });

    document.addEventListener('touchmove', (event) => {
        if (event.target && event.target.closest && event.target.closest('.allow-scroll')) {
            return;
        }
        event.preventDefault();
    }, { passive: false });

</script>
</body>
</html>
